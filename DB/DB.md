# DB

1. [Database](#database)
2. [Schema](#schema)
3. [DBMS(Database Management System)](#dbmsdatabase-management-System)
4. [DBMS(Relational Database Management System)](#rdbmsrelational-database-management-system )
   - [키(Key)](###키key)
5. [조인(Join)]()
6. [SQL,NoSQL]()
7. [정규화]()
8. [트랜잭션]()
9. [이상]()

---



### Database

- 정의

  - 데이터를 저장하는 곳

  - **여러 사람이 공유하고 사용할 목적으로 체계화해 통합,관리되는 정보의 집합**
  - 자료 파일을 통합하여 자료 항목의 **중복을 없애고 자료를 구조화하여 기억**시켜 놓은 자료의 집합체

- 특징
  - `실시간 접근` :  사용자 요구에 즉시 응답
  - `계속적 변화` : 데이터 삽입, 삭제, 수정을 통하여 최신 데이터를 동적으로 유지 가능
  - `내용 기반 참조` : 데이터를 참조할 때 데이터가 저장된 주소나 위치가 아닌 내용으로 참조
  - `동시 공유` : 여러 이용자가 동시에 원하는 데이터를 공유
  - `데이터 독립성` : 응용프로그램과 데이터베이스를 독립시킴으로써 데이터 논리적 구조를 변경시키더라도 응용프로그램은 변경되지 않는다.
- 장단점
  - 장점
    - 데이터 중복 최소화
    - 데이터 공유
    - 일관성, 무결성, 보안성 유지
    - 최신의 데이터 유지
    - 데이터의 표준화 기능
    - 데이터의 논리적, 물리적 독립성
    - 용이한 데이터 접근
    - 데이터 저장 공간 절약
  - 단점
    - 데이터베이스 전문가 필요
    - 많은 비용 부담
    - 데이터 백업과 복구가 어려움
    - 시스템의 복잡함
    - 대용량 디스크로 엑세스가 집중되면 과부하 발생



### Schema

: 데이터베이스의 구조와 제약조건에 관해 전반적인 명세를 기술한 것

- 스키마의 3계층
  - 스키마는 사용자의 관점에 따라 외부 스키마, 개념 스키마, 내부 스키마로 나뉜다
  - DBMS는 외부적 스키마에 따라 명시된 사용자의 요구를 개념적 스키마에 적합한 형태로 변경하고 이를 다시 내부적 스키마에 적합한 형태로 변환한다.
  - `외부 스키마(External Schema)` : 사용자나 프로그래머의 입장에서 데이터베이스의 모습으로 조직의 일부분을 정의한 것
  - `개념 스키마(Conceptual Schema)` :  모든 응용 시스템과 사용자들이 필요로하는 데이터를 통합한 조직 전체의 데이터베이스 구조를 논리적으로 정의한 것
  - `내부 스키마(Internal Schema)` : 물리적 저장장치의 입장에서 본 데이터베이스 구조로, 물리적인 저장장치와 밀접한 계층

![img](https://media.vlpt.us/images/ash3767/post/7a1fd722-8012-47a5-9b3a-f4512e309447/image.png) ![스키마](https://t1.daumcdn.net/cfile/tistory/9936823A5B698C4023)



### DBMS(Database Management System)

: **데이터베이스 내의 데이터를 접근 및 조작 할 수 있도록 해주는 소프트웨어 도구의 집합** , 사용자 또는 다른 프로그램의 요구를 처리하고 적절히 응답하여 데이터를 사용할 수 있도록 해준다.

- MySql, Oracle, MSSql, MongoDB 등



### RDBMS(Relational Database Management System) 

: RDB를 생성하고 수정하고 관리할 수 있는 소프트웨어, **관계형 모델을 기반으로하는 DBMS 유형**

- RDB(Relational Database) : **관계형 데이터 모델**에 기초를 둔 데이터 베이스 , 모든 데이터를 2차원의 테이블 형태로 표현한다

- 관계형 데이터 모델

  - `릴레이션(Relation)`
    - 개체를 표현하기 위한 데이터 구조로서 2차원 테이블로 표현
    - heading(스키마) , body(본체)로 구성
      - heading은 속성(attribute)이 n개가 모인 집합이며, 이름과 데이터형으로 구성
      - body는 속성값의 집합인 튜플(tuple)의 집합
    - SQL의 테이블과 대응
  - `튜플(Tuples)`
    - 하나의 개체를 의미하고 Relation에서 행으로 표현하며, 이를 릴레이션 상태(Relation State)라고도 함
    - 각 튜플은 유일해야 한다는 특징을 가지고 있음
    - SQL의 row와 대응
  - `속성(Attributes)`
    - 개체의 속성들을 의미하며 Relation에서 열로 표현
    - SQL의 column과 대응

  ![img](https://t1.daumcdn.net/cfile/tistory/99F23C505A77D5700B) ![img](https://media.vlpt.us/images/sysop/post/ede750c2-ec03-43d7-bad0-9de78b7cefe9/image.png)

  - #### 키(Key)

    : 데이터베이스에서 조건에 만족하는 튜플 검색 및 정렬시 다른 튜플들과 구별할 수 있는 유일한 기준이 되는 속성(Attribute)

    - 조건

      - **유일성** : 키로 하나의 튜플을 유일하게 식별할 수 있어야 한다. 즉, 키 값이 같은 튜플은 존재하지 않아야함
      - **최소성** : 꼭 필요한 최소한의 속성으로만 구성해야 한다.

    - 종류

      **<학생> 릴레이션** 

      | 학번 | 주민번호       | 성명   | 성별 |
      | ---- | -------------- | ------ | ---- |
      | 1001 | 810429-1231457 | 김형석 | 남   |
      | 1002 | 800504-1546781 | 김현천 | 남   |
      | 1002 | 811216-2547842 | 류기선 | 여   |
      | 1003 | 910322-1233445 | 홍영선 | 여   |

      **<수강> 릴레이션**

      | 학번 | 과목명 |
      | ---- | ------ |
      | 1001 | 영어   |
      | 1001 | 전산   |
      | 1002 | 영어   |
      | 1003 | 수학   |
      | 1004 | 영어   |
      | 1004 | 전산   |

      1. **후보키(Candidate Key)**

         - 릴레이션을 구성하는 속성들 중에서 **튜플을 유일하게 식별할 수 있는 속성들의 부분집합**
         - **모든 릴레이션은 반드시 하나 이상의 후보키를 가져야** 함
         - 릴레이션에 있는 모든 튜플에 대해서 **유일성, 최소성을 만족**시켜야 함

      2. **기본키(Primary Key)**

         - 후보키 중에서 선택한 Main Key
         - 한 릴레이션에서 **특정 튜플을 유일하게 구별할 수 있는 속성**
         - **NULL 값을 가질 수 없음** (개체 무결성의 첫번째 조건)
         - 기본키로 정의된 속성에는 **동일한 값이 중복되어 저장될 수 없음**(개체 무결성의 두번째 조건)

      3. **고유키(Unique Key)**

         - 테이블에 있는 데이터를 유일하게 식별
           - 값이 중복되지 않음
           - 값을 입력하지 않아도 된다. (NULL 허용)
         - 중복된 값을 허용하지 않지만 여러 개의 NULL 값은 허용
           - NULL 값은 비교 불가능함으로 여러 개 있어도 중복된 값이 아니기 때문이다
         - 고유 인덱스가 자동 생성됨

      4. Primary Key 와 Unique Key 차이점

         - Primary Key와 Unique Key는 유일함이라는 조건을 만족하는 것은 공통적
         - 하지만 Primary Key는 테이블당 하나만 생성할 수 있고, Unique Key는 여러 개 생성 가능
         - 또한, Primary Key는 NULL 값을 가질 수 없지만, Unique Key는 가질 수 있음
         - 

      5. **대체키(Alternate Key)**

         - **후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키**

         - 보조키라고도 함

      6. **슈퍼키(Super Key)**

         - **슈퍼키는 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키**로서 릴레이션을 구성하는 모든 튜플 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타내지 않음
         - 릴레이션을 구성하는 모든 튜플에 대해 **유일성은 만족하지만, 최소성은 만족시키지 못함**

      7. **외래키(Foreign key)**

         - 관계를 맺고 있는 릴레이션 R1, R2에서 R1이 참조하고 있는 릴레이션의 R2의 기본키와 같은 R1 릴레이션의 속성을 외래키라고 함
         - 즉, **두 테이블을 서로 연결하는 데 사용하는 키**
         - 외래키는 참조되는 릴레이션의 기본키와 대응되어 릴레이션 간에 참조관계를 표현하는데 중요한 도구
         - 외래키로 지정되면 참조 테이블의 기본키에 없는 값을 입력할 수 없다.(참조 무결성)

    - 무결성 제약 조건

      - 


# index

## 왜?

* 책의 색인, 배열의 index 모두 빠르게 데이터를 조회하기 위한 것으로 DB의 index와 그 목적이 같다.
* 데이터에 대한 검색속도를 향상 시키기 위한 자료구조
* 테이블 내의 1개의 컬럼 혹은 여러개의 컬럼을 이용해 생성될 수 있다.

>
'느려'

index를 사용하지 않은 컬럼들을 조회 할 때 테이블 전체를 탐색(Table Full Scan)해야한다. 그렇기 때문에 처리속도가 떨어진다. Table Full Scan을 하지 않으려고 index를 만들어 데이터 관리를 한다.

## 인덱스 장/단점

장점

* 검색 속도 향상
* 시스템의 부하를 줄일 수 있다.

단점

* 추가 저장공간이 필요하다.
* 삽입,삭제,갱신이 빈번한 컬럼에서는 성능이 저하될 수 있음

## 언제?

* 삽입,삭제,갱신이 적은 컬럼 
* 데이터의 중복도가 낮은 컬럼
* 검색,join등이 자주 발생하는 컬럼
* 규모가 큰 테이블

## 삽삭갱과 index
>
index가 적용된 컬럼에 insert,update,delete가 수행된다면 일련의 연산을 추가적으로 진행하고 그에 따른 오버헤드가 발생한다.

* insert : 새로운 데이터에 인덱스를 추가해야함
* delete : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행해야함
* update : 기존의 인덱스를 사용하지 않음 처리하고 갱신된 데이터에 대해 인덱스를 추가해야함

## 문제점
>삭제와 갱신이 빈번하게 일어난다면?

인덱스는 정렬된 상태로 저장이 되는데 insert는 기존에 데이터를 뒤로 밀어야하는 경우가 발생할 수 있어서 비효율적이다.
update와 delete는 인덱스를 삭제하는게 아니라 사용하지  않음 처리를 해준다. 그렇기 때문에 인덱스가 계속 누적되어 sql처리시에 오히려 성능저하가 나타날 수 있다. 그래서 사용하지 않는 index는 바로 제거를 해주어야한다.

## 어떻게?
> 해쉬와 B+Tree를 이용해 구현함

* DB 인덱스에서 해시 테이블이 사용되는 경우는 제한적인데, 그러한 이유는 해시가 등호(=) 연산에만 특화되었기 때문이다. 해시 함수는 값이 1이라도 달라지면 완전히 다른 해시 값을 생성하는데, 이러한 특성에 의해 부등호 연산(>, <)이 자주 사용되는 데이터베이스 검색을 위해서는 해시 테이블이 적합하지 않다.

* B+Tree는 자식노드가 2개 이상인 B-Tree를 개선시킨 자료구조로서 리프노드에만 인덱스와 데이터를 가지고 있고 나머지 노드들은 데이터를 위한 인덱스만을 갖는다.
![](https://images.velog.io/images/dbtlwns/post/b0197a7c-d51f-4736-8663-a01552466db8/image.png)

## 인덱스 예시
![](https://images.velog.io/images/dbtlwns/post/8841fe0e-8d30-49fe-8568-aff35ec38bcd/image.png)
## 출처 및 참고사이트
* [망나니개발자님 블로그](https://mangkyu.tistory.com/96)
* [위키백과 인덱스](https://ko.wikipedia.org/wiki/%EC%9D%B8%EB%8D%B1%EC%8A%A4_(%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4))

# 트랜잭션 (Transaction)
- 트랜잭션이란
   - 데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위이며, 여러개의 연산이 수행될 수 있다.
   ```
   트랜잭션의 예(A계좌에서 B계좌로 일정 금액을 이체)
      1. A계좌의 잔액을 확인
      2. A계좌의 금액에서 이체할 금액을 빼고 다시 저장
      3. B계좌의 잔액을 확인
      4. B계좌의 금액에서 이체할 금액을 더하고 다시 저장
   이러한 과정을 모두 합쳐 계좌이체라는 하나의 작업단위를 구성
   ```
   - 수행중에 한 작업이라도 실패하면 전부 실패하고, 모두 성공해야 성공이라고 할 수 있다.
   - 하나의 트랜재션은 Commit, Rollback 된다.
      - Commit
         - 한개의 논리적 단위에 대한 작업(트랜잭션)에 대한 작업이 성공적으로 끝나 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산
      - Rollback
         - 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었어도 트랜잭션이 행한 모든 연산을 취소하는 연산
   - 트랜잭션의 성질(ACID)
      - Atomicity(원자성)
         - 트랜잭션의 모든 연산이 정상적으로 수행 완료되거나, 아니면 전혀 어떠한 연산도 수행되지 않은 상태를 보장
      - Consistency(일관성)
         - 트랜잭션이 성공적으로 완료되면 일관적인 DB상태를 유지
         - 일관성이란 위의 계좌이체 예제에서 금액의 데이터 타입이 정수(integer)에서 문자열(String)으로 되지않는 것
      - Isolation(독립성)
         - 트랜잭션 수행시 다른 트랜잭션의 작업이 끼어들지 못하도록 보장하는 것
         - 트랜잭션은 동시에 실행될 경우 다른 트랜잭션에 의해 영향을 받지 않고 독립적으로 실행되어야 함.
      - Durability(지속성)
         - 성공적으로 수행된 트랜잭션은 영원히 반영
   - 트랜잭션의 필요성
      -  DB서버에 여러 개의 클라이언트가 동시에 액세스 하거나 응용프로그램이 갱신을 처리하는 과정에서 중단될 수 있는 경우 등 데이터 부정합을 방지하고자 할 때 사용
      -  트랜잭션에서 중요한 것은 스케줄 관리, 스케줄을 잘못 짜면 데드락에 빠지게 됨
   - 트랜잭션 격리 수준
      - Isolation Level(격리 수준)이란
         - 각기 다른 트랜잭션들이 서로에게서 어느 정도 격리되어 있는지를 나타냄
      - Lsolation Level의 종류
         - Read Uncommitted (레벨0)
            - 잠금을 일절 실행하지 않아 미처 커밋되지 않고 트랜잭션이 진행 중인 기록조차도 조회할 수 있도록 하는 격리 수준
            - 어떤 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 다른 사용자는 아직 완료되지 않은(Uncommitted 혹은 Dirty) 트랜잭션이지만 변경된 데이터인 B를 읽을 수 있다.
         - Read Committed (레벨1)
            - 어떤 트랜잭션의 변경 내용이 Commit 되어야만 다른 트랜잭션에서 조회할 수 있다.
         - Repeatable Read (레벨2)
            - 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있는 격리 수준
         - Serializable (레벨3)
            - 읽기 작업에도 공유 잠금을 설정, 동시에 다른 트랜잭션에서 이 레코드를 변경하지 못함
            - 동시처리 능력이 다른격리수준보다 떨어지고, 성능 저하가 발생     
   - 낮은 단계의 Isolation Level에서 발생하는 현상
     ![isolation-level](https://user-images.githubusercontent.com/61149599/124345150-0bc64f80-dc12-11eb-8bb7-8c92d56bdac9.png)
      - Dirty Read
         - 커밋되지 않은 수정 중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상
      - Non-Repeatable Read
         - 한 트랜잭션에서 같은 쿼리를 두번 수행할 때 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써 두 쿼리의 결과가 상이하게 나타나는 비 일관성 현상
      - Phantom Read
         - 한 트랜잭션 내에서 같은 쿼리문이 실행되었음에도 불구하고 조회 결과가 다른 경우
         - 트랜잭션 도중 새로운 레코드가 삽입되는 것을 허용하기 때문에 나타난다.
      *** https://joont92.github.io/db/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80-isolation-level/

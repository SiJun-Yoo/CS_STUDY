
**:book: Contents**
+ [1. 프로세스와 스레드의 차이(Process vs Thread)]
+ [2. 멀티 프로세스 대신 멀티 스레드를 사용하는 이유]
+ [3. Thread-safe]
+ [4. 동기화 객체의 종류]
+ [5. 뮤텍스와 세마포어의 차이]
+ [6. 스케줄러]
+ [7. 동기와 비동기]
+ [8. 프로세스 동기화]
+ [9. 메모리 관리 전략]
+ [10. 가상 메모리]
+ [11. 캐시의 지역성]
+ [12. 교착상태(데드락, Deadlock)의 개념과 조건]
+ [13. 사용자 수준 스레드와 커널 수준 스레드]
+ [14. 외부 단편화와 내부 단편화]
+ [15. Context Switching]
+ [16 Swapping]


## 1. 프로세스와 스레드의 차이(Process vs Thread)
#### 대략적인 컴퓨터구조

![image-20210617120119156](https://user-images.githubusercontent.com/77487962/122360831-ac214080-cf91-11eb-9954-5a8c49b41bd9.png)



> **프로그램이란?**

윈도우/리눅스/유닉스 같은 것들 안에서 실행될 수 있도록 만들어 진 것

=> 어떠한 작업을 위해 운영체제 위에서 실행할 수 있는 파일

* C, Java 등등으로 만들어 진다
* Kakao talk, Power Point 같은 것

 

> **프로세스란?**

**메모리에 적재되어 CPU에 의해서 실행중인 프로그램**을 말한다.

이때 프로그램 명령어와 데이터들이 메모리에 올라옴

실행 중(Running ) 또는 실행 대기 중인 상태

\* CPU (Central Processing Unit) : 컴퓨터에서 기억, 해석, 연산, 제어라는 4대 기능을 종합하는 중앙처리장치

 

> **프로세서란?**

프로세스가 동작 될 수 있도록 하는 하드웨어(= CPU)

 

> **프로세스의 구성 요소**

![image-20210617163852934](https://user-images.githubusercontent.com/77487962/122361220-028e7f00-cf92-11eb-996a-aeb9c9a7a497.png)




1. 프로그램 카운터 (PC)

   다음에 실행될 명령어의 주소를 가지고 있어 실행될 기계어 코드의 위치를 저장한다.

   즉, **다음에 실행될 명령어 포인터**라고 할 수 있다.

 

2. CPU 레지스터 내용

3. 프로세스 Stack

   함수에서 사용되는 **데이터 정보**를 저장한다.

   즉, 함수 매개변수(Parameter), 함수 내부에서 사용되는 지역변수, 복귀 주소 (return addresss)가 저장된다. 함수 호출이 완료되면 메모리 해제된다.

 

4. 데이터(data) 

   **전역변수**나 **정적변수**(static 변수) 가 저장된다.

   프로그램 시작 시 동시 할당되고, 종료 시 해제 된다.

 

5. 힙(Heap) 

   개발자가 필요에 의해 **동적으로 할당**하는 메모리

   할당해야할 메모리를 런타임에 결정할 수 있는 경우, 유용하게 사용된다.

   

6. 텍스트(Text)

   컴파일된 프로그램 코드가 저장된다.



화살표 방향의 의미는,

Heap 영역은 아래에서 위 방향으로 데이터를 저장해나가고, Stack은 맨위부터 아래방향으로 데이터 저장해 나간다는 뜻이다.

![image-20210617163941860](https://user-images.githubusercontent.com/77487962/122361304-1639e580-cf92-11eb-85d4-d784113baf23.png)


 

> **프로세스 상태 (Process State)**

1. New : 프로세스가 생성되는 중

2. Running : CPU에서 명령이 실행되는 중

3. Waiting : 프로세스가 어떤 event(입출력 완료, signal 수신)가 발생하기를 기다리는 중

4. Ready : 프로세스가 CPU에 할당되어 실행되기를 기다리는 중

5. Terminated : 프로세스 실행 종료

 

그 다음을 이해하기 위해 아래 내용을 반드시 숙지해야 한다.

> 컴퓨터 하드웨어인 CPU는 여러개의 프로세스를 동시에 실행할 수 없다.
> 언제나 한순간에 오직 1개의 프로세스를 수행한다.
> 다만, 운영체제의 멀티태스킹(Multi tasking)과 스케줄링 기법으로 여러개의 프로세스가 동시에 실행되는 것처럼 보일뿐이다. 

 

때문에 우리는 일반적인 운영체제에서 프로세스 상태와 변화를 이해해야 한다.



![img](https://blog.kakaocdn.net/dn/ctV6Lw/btqJCRlC0HS/LI1ujyTB5lGXkp3CcjrUP0/img.png)프로세스의 상태 변화

**=> 이를 통해 운영체제는 멀태태스킹 멀티프로세싱을 달성하게 된다.**



> 스레드 (Thread)

![image-20210617165835084](https://user-images.githubusercontent.com/77487962/122361387-28b41f00-cf92-11eb-8db0-dc5d58e12038.png)


프로세스 내에서 실행되는 프로그램 코드의 흐름을 말한다.

하나의 프로세스 내에는 반드시 하나 이상의 스레드가 존재한다.

각 스레드는 스레드ID, 프로그램 카운터(PC), 레지스터 집합, 스택을 독립적으로 소유한다.

같은 프로세스 내에 스레드들은 서로 텍스트 영역(코드), 데이터 영역, 열린 파일 등의 시스템 자원을 공유한다.





> 스레드는 왜 필요한가?

여러개의 단위 작업으로 구성된 프로그램에서 요청을 동시에 처리하기 위해서다.

 

예) 웹 브라우저 

이미지/텍스트를 표시하는 스레드, 네트워크에서 데이터를 가져오는 스레드, 파일 다운로드 받는 스레드 등등

한 프로세스 내에서 여러개의 작업을 해야하는 경우가 생긴다. 

 

| 응답성 (Responsiveness)      | 다른 스레드의 실행 시간이 길거나 입출력 요청으로 인해 block 되더라도 계속 실행되는 것을 허용한다. |
| ---------------------------- | ------------------------------------------------------------ |
| 자원 공유 (Resource sharing) | 프로세스 내 자원(코드, 데이터)를 자동적으로 공유한다.        |
| 경제성 (Economy)             | 만약 각각의 작업을 위해 별도의 프로세스를 생성한다면, 프로세스 생성 및 문맥 교환(Context switch)으로 인해 overhead가 발생한다. 이에 비해 멀티 스레딩 방식은 훨씬 경제적이다. |
| 확장성 (Scalability)         | 멀티 프로세서 시스템에서 병렬성이 증가한다. (하나의 프로세스라 Context Switch될 일이 없기 때문에 CPU가 여러개일 때 병렬적으로 사용될 수 있음) |



**정리**

|      | Process                                   | Thread                               |
| ---- | ----------------------------------------- | ------------------------------------ |
| 1    | 실행 중인 프로그램                         | 프로세스의 실행 단위                 |
| 2    | 종료하는데 시간이 걸림                     | 종료하는데 시간이 덜 걸림            |
| 3    | 생성하는데 더 시간이 걸림                  | 생성 시간이 덜 걸림                  |
| 4    | Context전환에 더 많은 시간이 걸림          | Context전환에 소요되는 시간이 줄어듬 |
| 5    | 대화 측면에서 프로세스의 효율성이 떨어짐    | 대화면에서 쓰레드가 더 효율적        |
| 6    | 더 많은 Resource를 소비                   | 적은 Resource 소비                   |
| 7    | 메모리 공유 X                             | 메모리 공유 O                        |
| 8    | heavy-weight process                     | light-weigth process                 |
| 9    | 프로세스 전환 -> 운영체제 인터페이스 사용   | 스레드 전환 ->운영체제 호출 X        |

# 데드락
* 프로세스나 스레드가 결코 일어날 수 없는 특정 이벤트를 기다리는 상태
* 서로의 자원을 기다리다 무한대기에 빠지는 상황

# 데드락의 발생조건
1. 상호 배제 조건
* 여러 프로세스가 동시에 한 자원에 접근하지 못함
* 즉 한 번에 프로세스 하나만 특정 자원을 사용할 수 있다.

2. 점유와 대기 조건
* 한 프로세스가 자원을 점유한 상태로 다른 자원을 점유하기 위해 대기할 수 있음

3. 비선점 조건
* 이미 할당된 자원을 강제로 빼앗을 수 없음

4. 순환대기
* 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야한다.(싸이클)
**위 4가지 조건을 모두 만족해야 교착상태가 발생함**

# 예방
* 필요 조건 중 하나를 거부하고 예방->점유와 대기 조건을 거부하면됨
* 하지만 이렇게 한다면 자원을 효율적으로 사용할 수 없음

# 회피
* 은행원 알고리즘
* 시스템을 안전/불안전 상태로 구분하여 안전 상태일 땐 자원할당 불안전 상태일 땐 대기시킴
* 할당할 자원 수 고정, 프로세스 수 고정등 많은 조건이 필요
**자원을 요청할 때 마다 시스템의 상태를 판단해야하기 때문에 오버헤드가 심함**

# 탐지
* 데드락이 발생했는지 여부를 탐색
* 자원할당 그래프를 통해 탐지를 함(프로세스간에 순환을 알아냄)
* 주기적으로, 자원즉시 할당여부, CPU이용률등 일정한 기준에 따라 실시함

# 복구
순환대기를 깨서 교착상태로 부터 회복
* 모든 프로세스 중단
* 순환대기가 깨질 때 까지 프로세스를 종료함(매번 탐지 알고리즘을 호출하기 때문에 부담)
* 순환대기에 포함된 프로세스의 제어권을 뺏고 롤백시켜버림
* 시스템마다 다른 기준으로 일정한 우선순위에 따라 프로세스들을 종료시킴

## 2. 멀티 스레드
  + 멀티 스레드란
    + 하나의 프로세스에서 여러개의 스레드를 만들어 자원의 생성과 관리의 중복을 최소화하는 것
    + 데이터, 힙, 스택 영역 중 스택 영역만 비공유, 데이터와 힙 영역은 공유
  + 장점
    + 멀트 프로세스에 비해 메모리 자원소모가 줄어듬.
    + 데이터, 힙 영역을 통해서 스레드간 통신이 가능하여 프로세스간 통신보다 빠름.
    + 스레드의 Context Switching이 프로세스의 Context Switching보다 빠름.
      + Context Switching시 스레드는 Stack 영역만 처리, 프로세스는 데이터, 힙, 스택 모두 처리
      ```
      Context Switching이란
        - 현재 진행하고 있는 Task(Process, Thread)의 상태를 저장하고 다음 진행할 Task의 상태 값을 읽어 적용하는 과정
      ```
  + 단점
    + 동기화 문제
      + 데이터, 힙 영역을 공유하기 때문에 어떤 스레드가 다른 스레드가 사용중인 변수나 자료 구조에 접근하여 엉뚱한 값을 읽거나 수정할 수 있다.
    + 동기화를 위해 락을 과도하게 사용하면 성능이 저하
    + 하나의 스레드가 비정상적으로 동작하면 전체 스레드가 종료될 수 있다.
    
## 3. Thread-safe
  + Thread-safy란
    + 멀티 스레드 프로그래밍에서 일반적으로 어떤 함수나 변수, 혹은 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없음을 뜻함.
  + Thread Safety 보장하는 기법
    + Re-entrancy
      + 어떤 함수가 한 스레드에 의해 호출되어 실행 중일 때, 다른 스레드가 그 함수를 호출하더라도 그 결과가 각각에게 올바로 주어져야 한다.
    + Thread-local storage
      + 공유 자원의 사용을 최대한 줄여 각각의 스레드에서만 접근 가능한 저장소들을 사용함으로써 동시 접근을 막는다.
    + Atomic Operation
      + 데이터 변경시 atomic하게 데이터에 접근하도록 만든다.
      + Atomic(원자성)은 데이터베이스의 트랜잭션 ACID의 중 A이다. 하나의 트랙잭션은 모두 성공이거나 모두 실패여야 한다.
    + Mutual exclusion
      + 스레드에 락이나 세마포어를 걸어서 공유자원에는 하나의 스레드만 접근 가능하게 합니다. (Java의 synchronized)
## 4. 동기화(Synchronization)&비동기(Asynchronization)
  + 동기화란
    + 프로세스 또는 스레드들이 수행되는 시점을 조절하여 서로가 알고 있는 정보가 일치하는 것
  + 동기화가 필요한 이유
    + 데이터의 일관성이 깨지기 때문에 연산결과가 잘못 반환될 가능성이 있기 때문에
    ```
      ex) a = 2라는 자원이 있다. 
      P1는 프로세스는 a라는 값을 이용하여 어떤 로직 수행 그런데 만약 그 사이 P2라는 프로세스가 a의 값을 3으로 변경하면
      프로그램은 원하는 형태의 값을 반환하지 않음.
    ```
  + Race Condition(경쟁 상태)
    + 여러 프로세스나 스레드가 동기화 매커니즘 없이 자원에 접근하려는 상황, 접근 순서에 따라 실행 결과가 달라질 수 있음.
  + 동기화 방법
    + 유저 동기화
      + Critical Selection(임계 구역)
        + 공유되는 자원에서 문제가 발생하지 않도록 독점을 보장해주는 영역
        + 반드시 하나의 프로세스 또는 스레드만 진입이 가능
        + 임계 구역을 해결하는 3가지 조건
          + Mutual exclusion(상호배제)
            + 하나의 프로세스 또는 스레드가 임계구역에서 동작중이면 다른 프로세스는 접근할 수 없다.
          + Progress(진행)
            + 임계구역에 작업중인 프로세스 또는 스레드가 없으면 임계구역으로 진입하려는 프로세스 또는 스레드를 적절히 선택해서 진입할 수 있도록 한다.
          + Bounded waiting(유한대기)
            + 임계구역에 진입하기 위해 대기하는 모든 스레드는 유한 시간 이내에 임계구역으로 진입할 수 있어야 한다.
        + 피터슨의 알고리즘
          > https://jhnyang.tistory.com/37
    + 커널 동기화
      + Mutex(뮤텍스)
        + 하나의 프로세스 또는 스레드만 접근 가능하도록 관리하는 방식
      + Semaphore(세마포어)
        + 여러개의 프로세스가 접근 가능한 공유자원을 관리하는 방식
      ```
      * 세마포어는 뮤텍스가 될 수 있지만, 역은 성립하지 않음.
      * 세마포어는 다른 프로세스가 세마포어를 해제할 수 있지만, 뮤텍스는 락을 획득한 프로세스나 스레드만 가능
      ```
  + 비동기화란
    + '동기'가 아닌 것.
  + 비동기식, 비동기적이다.
    + 어떤 작업을 요청했을 때 그 작업이 종료될 때까지 기다리지 않고(작업을 위임하고), 다음 작업을 수행한다. 요청했던 작업이 끝나면 결과를 받고, 그에 따른 추가 작업이 있다면 수행한다.

      + 요청 순서에 상관없이, 동시에 다수의 작업을 처리할 수 있다.
      + 작업이 끝날 때 따로 이벤트를 감지하고 결과를 받아 그에 따른 추가 작업을 해줘야하기 때문에, 비교적 느릴 수 있다.
      + I/O 작업이 잦고, 빠른 응답속도를 요구하는 프로그램에 적합하다.
    
      ### 4-1. 뮤텍스와 세마포어의 차이
      - 뮤텍스(Mutex)
        - 공유된 자원의 데이터를 여러 스레드가 접근하는 것을 막는 것
        - 상호배제라고도 하며, Critical Section을 가진 스레드의 Running time이 서로 겹치지 않도록 각각 단독으로 실행하게 하는 기술이다.
        - 다중 프로세스들의 공유 리소스에 대한 접근을 조율하기 위해 synchronized 또는 lock을 사용한다.
           - 즉, 뮤텍스 객체를 두 스레드가 동시에 사용할 수 없다.
      - 세마포어(Semaphore)
        - 공유된 자원의 데이터를 여러 프로세스가 접근하는 것을 막는 것
        - 리소스 상태를 나타내는 간단한 카운터로 생각할 수 있다.
           - 운영체제 또는 커널의 한 지정된 저장장치 내의 값이다.
           - 일반적으로 비교적 긴 시간을 확보하는 리소스에 대해 이용한다.
           - 유닉스 시스템 프로그래밍에서 세마포어는 운영체제의 리소스를 경쟁적으로 사용하는 다중 프로세스에서 행동을 조정하거나 또는 동기화 시키는 기술이다.
        - 공유 리소스에 접근할 수 있는 프로세스의 최대 허용치만큼 동시에 사용자가 접근하여 사용할 수 있다.
        - 각 프로세스는 세마포어 값은 확인하고 변경할 수 있다.
           - 사용 중이지 않는 자원의 경우 그 프로세스가 즉시 자원을 사용할 수 있다.
           - 이미 다른 프로세스에 의해 사용 중이라는 사실을 알게 되면 재시도하기 전에 일정 시간을 기다려야 한다.
           - 세마포어를 사용하는 프로세스는 그 값을 확인하고, 자원을 사용하는 동안에는 그 값을 변경함으로써 다른 세마포어 사용자들이 기다리도록 해야한다.
        - 세마포어는 이진수 (0 또는 1)를 사용하거나, 또는 추가적인 값을 가질 수도 있다.
      - 차이
        1. 가장 큰 차이점은 관리하는 동기화 대상의 개수
           - Mutex는 동기화 대상이 오직 하나뿐일 때, Semaphore는 동기화 대상이 하나 이상일 때 사용한다.
        2. Semaphore는 Mutex가 될 수 있지만 Mutex는 Semaphore가 될 수 없다.
           - Mutex는 상태가 0, 1 두 개 뿐인 binary Semaphore
        3. Semaphore는 소유할 수 없는 반면, Mutex는 소유가 가능하며 소유주가 이에 대한 책임을 가진다.
           - Mutex 의 경우 상태가 두개 뿐인 lock 이므로 lock 을 가질 수 있다.
        4. Mutex의 경우 Mutex를 소유하고 있는 스레드가 이 Mutex를 해제할 수 있다. 하지만 Semaphore의 경우 이러한 Semaphore를 소유하지 않는 스레드가 Semaphore를 해제할 수 있다.
        5. Semaphore는 시스템 범위에 걸쳐있고 파일시스템상의 파일 형태로 존재하는 반면 Mutex는 프로세스 범위를 가지며 프로세스가 종료될 때 자동으로 Clean up 된다.
        
## 5. Context Switching
  + Computer가 매번 하나의 Task만 처리할 수 있다면?
      해당 Task가 끝날때까지 다음 Task는 기다릴 수 밖에 없습니다.
      또한 반응속도가 매우 느리고 사용하기 불편합니다.
  + 그렇다면 다양한 사람들이 동시에 사용하는 것처럼 하기 위해선?
      Computer multitasking을 통해 빠른 반응속도로 응답할 수 있습니다.
      빠른 속도로 Task를 바꿔 가며 실행하기 때문에 사람의 눈으론 실시간처럼 보이게 되는 장점이 있습니다.
      CPU가 Task를 바꿔 가며 실행하기 위해 Context Switching이 필요하게 되었습니다.
  + Context Switching이란?
     - 현재 진행하고 있는 Task(Process, Thread)의 상태를 저장하고 다음 진행할 Task의 상태 값을 읽어 적용하는 과정을 말한다.
  + Context Switching 과정
     - Task의 대부분 정보는 Register에 저장되고 PCB(Process Control Block)로 관리된다.
        - 현재 실행하고 있는 Task의 PCB 정보를 저장한다. (Process Stack, Ready Queue)
        - 다음 실행할 Task의 PCB 정보를 읽어 Register에 적재하고 CPU가 이전에 진행했던 과정을 연속적으로 수행할 수 있다.
     - Context Switching Cost (Process vs Thread)
        - Process Context Switching 비용 > Thread Context Switching 비용
        - Thread는 Stack 영역을 제외한 모든 메모리를 공유하므로 Context Switching 수행 시 Stack 영역만 변경하면 되기 때문에 비용이 적게 든다.

  + PCB(Process Control block) 구조
     ![pcb](https://user-images.githubusercontent.com/77487962/126058774-e29be1c0-0c11-4998-aaac-7f49c22b6a19.PNG)
     - Process State : 프로세스 상태(Create, Ready, Running, waiting, terminated)
     - Process Counter : 다음 실행할 명령어의 주소값
     - CPU Registers: accumulator, index register, stack pointers, general purpose registers.
     
  + Example
     - i에 10을 넣고 Context Switching을 발생시키고 20넣고 Context Switching을 발생시키는 과정입니다.
     ![1](https://user-images.githubusercontent.com/77487962/126058839-aafaf78f-2303-4d60-895c-3b99f34faf7e.PNG)

     - yield()를 호출하여 CPU를 양보하여 Context Switching이 발생하게됩니다.
     ![2](https://user-images.githubusercontent.com/77487962/126058868-d7cef579-bb43-4038-8ce1-11f8525c4f86.PNG)

     - Context Switching을 위해 PC, SP값을 Stack에 저장하게 됩니다.
     ![3](https://user-images.githubusercontent.com/77487962/126058897-e6893a65-2edc-4eab-86e1-3ef0334f402d.PNG)

     - 현재 PC값과 SP값을 System Call yield()로 조정합니다.
     ![4](https://user-images.githubusercontent.com/77487962/126058914-d4a94dc6-fc4e-4d61-8c08-294de136bc27.PNG)

     - context Switching을 진행하기 위해 PC값을 변경합니다.
     ![5](https://user-images.githubusercontent.com/77487962/126058937-e5d58019-14e0-41ab-af7f-f0a6f7d0ba19.PNG)

     - 이전의 Task의 PC값과 SP값을 PCB에 담아 저장합니다.
     ![6](https://user-images.githubusercontent.com/77487962/126058949-ed0bb661-19d1-4f84-8528-9d2a75c8c06e.PNG)

     - Context 저장을 완료한 다음 Process X를 실행하게 됩니다.No Image
     ![7](https://user-images.githubusercontent.com/77487962/126059002-69f9a919-cb93-4a20-8c07-2d913c4b8917.PNG)

     - Process X가 진행이 완료되고 다시 Context Switch가 발생하게 된다면 이전 Process로 돌아올 준비를 합니다.
     ![8](https://user-images.githubusercontent.com/77487962/126059009-5b681a83-3d0f-4a20-9185-0e5cc9f7aeaa.PNG)

     - Stack에 담긴 PC, SP를 읽어 다시 CPU에 적재합니다.No Image
     ![9](https://user-images.githubusercontent.com/77487962/126059021-84a1f7bb-37ab-48cf-baab-468f8f02006e.PNG)

     - 다시 돌아온 Context지만 다시 yield()를 발생시켰기 때문에 위 과정을 다시 반복진행합니다.No Image
     ![10](https://user-images.githubusercontent.com/77487962/126059027-c4686361-6553-435b-b5c3-8cecaab3d1e8.PNG)
  
  + Context Switching Cost
     + Context Switching이 발생하게 되면 많은 Cost가 소요됩니다.
          + Cache 초기화
          + Memory Mapping 초기화
          + Kernel은 항상 실행되어야 합니다. (메모리의 접근을 위해서..)
  + Process vs Thread
     + Context Switching 비용은 Process가 Thread보다 많이 듭니다.
     + Thread는 Stack 영역을 제외한 모든 메모리를 공유하기 때문에
     + Context Switching 발생시 Stack 영역만 변경을 진행하면 됩니다.

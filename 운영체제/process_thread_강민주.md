#### 대략적인 컴퓨터구조

![image-20210617120119156](C:\Users\cherr\AppData\Roaming\Typora\typora-user-images\image-20210617120119156.png)

![image-20210617120119156](https://user-images.githubusercontent.com/77487962/122360831-ac214080-cf91-11eb-9954-5a8c49b41bd9.png)



> **프로그램이란?**

윈도우/리눅스/유닉스 같은 것들 안에서 실행될 수 있도록 만들어 진 것

=> 어떠한 작업을 위해 운영체제 위에서 실행할 수 있는 파일

* C, Java 등등으로 만들어 진다
* Kakao talk, Power Point 같은 것

 

> **프로세스란?**

**메모리에 적재되어 CPU에 의해서 실행중인 프로그램**을 말한다.

이때 프로그램 명령어와 데이터들이 메모리에 올라옴

실행 중(Running ) 또는 실행 대기 중인 상태

\* CPU (Central Processing Unit) : 컴퓨터에서 기억, 해석, 연산, 제어라는 4대 기능을 종합하는 중앙처리장치

 

> **프로세서란?**

프로세스가 동작 될 수 있도록 하는 하드웨어(= CPU)

 

> **프로세스의 구성 요소**

![image-20210617163852934](C:\Users\cherr\AppData\Roaming\Typora\typora-user-images\image-20210617163852934.png)



1. 프로그램 카운터 (PC)

   다음에 실행될 명령어의 주소를 가지고 있어 실행될 기계어 코드의 위치를 저장한다.

   즉, **다음에 실행될 명령어 포인터**라고 할 수 있다.

 

2. CPU 레지스터 내용

3. 프로세스 Stack

   함수에서 사용되는 **데이터 정보**를 저장한다.

   즉, 함수 매개변수(Parameter), 함수 내부에서 사용되는 지역변수, 복귀 주소 (return addresss)가 저장된다. 함수 호출이 완료되면 메모리 해제된다.

 

4. 데이터(data) 

   **전역변수**나 **정적변수**(static 변수) 가 저장된다.

   프로그램 시작 시 동시 할당되고, 종료 시 해제 된다.

 

5. 힙(Heap) 

   개발자가 필요에 의해 **동적으로 할당**하는 메모리

   할당해야할 메모리를 런타임에 결정할 수 있는 경우, 유용하게 사용된다.

   

6. 텍스트(Text)

   컴파일된 프로그램 코드가 저장된다.



화살표 방향의 의미는,

Heap 영역은 아래에서 위 방향으로 데이터를 저장해나가고, Stack은 맨위부터 아래방향으로 데이터 저장해 나간다는 뜻이다.

 ![image-20210617163941860](C:\Users\cherr\AppData\Roaming\Typora\typora-user-images\image-20210617163941860.png)

 

> **프로세스 상태 (Process State)**

1. New : 프로세스가 생성되는 중

2. Running : CPU에서 명령이 실행되는 중

3. Waiting : 프로세스가 어떤 event(입출력 완료, signal 수신)가 발생하기를 기다리는 중

4. Ready : 프로세스가 CPU에 할당되어 실행되기를 기다리는 중

5. Terminated : 프로세스 실행 종료

 

그 다음을 이해하기 위해 아래 내용을 반드시 숙지해야 한다.

> 컴퓨터 하드웨어인 CPU는 여러개의 프로세스를 동시에 실행할 수 없다.
> 언제나 한순간에 오직 1개의 프로세스를 수행한다.
> 다만, 운영체제의 멀티태스킹(Multi tasking)과 스케줄링 기법으로 여러개의 프로세스가 동시에 실행되는 것처럼 보일뿐이다. 

 

때문에 우리는 일반적인 운영체제에서 프로세스 상태와 변화를 이해해야 한다.



![img](https://blog.kakaocdn.net/dn/ctV6Lw/btqJCRlC0HS/LI1ujyTB5lGXkp3CcjrUP0/img.png)프로세스의 상태 변화

**=> 이를 통해 운영체제는 멀태태스킹 멀티프로세싱을 달성하게 된다.**



> 스레드 (Thread)

![image-20210617165835084](C:\Users\cherr\AppData\Roaming\Typora\typora-user-images\image-20210617165835084.png)

프로세스 내에서 실행되는 프로그램 코드의 흐름을 말한다.

하나의 프로세스 내에는 반드시 하나 이상의 스레드가 존재한다.

각 스레드는 스레드ID, 프로그램 카운터(PC), 레지스터 집합, 스택을 독립적으로 소유한다.

같은 프로세스 내에 스레드들은 서로 텍스트 영역(코드), 데이터 영역, 열린 파일 등의 시스템 자원을 공유한다.





> 스레드는 왜 필요한가?

여러개의 단위 작업으로 구성된 프로그램에서 요청을 동시에 처리하기 위해서다.

 

예) 웹 브라우저 

이미지/텍스트를 표시하는 스레드, 네트워크에서 데이터를 가져오는 스레드, 파일 다운로드 받는 스레드 등등

한 프로세스 내에서 여러개의 작업을 해야하는 경우가 생긴다. 

 

| 응답성 (Responsiveness)      | 다른 스레드의 실행 시간이 길거나 입출력 요청으로 인해 block 되더라도 계속 실행되는 것을 허용한다. |
| ---------------------------- | ------------------------------------------------------------ |
| 자원 공유 (Resource sharing) | 프로세스 내 자원(코드, 데이터)를 자동적으로 공유한다.        |
| 경제성 (Economy)             | 만약 각각의 작업을 위해 별도의 프로세스를 생성한다면, 프로세스 생성 및 문맥 교환(Context switch)으로 인해 overhead가 발생한다. 이에 비해 멀티 스레딩 방식은 훨씬 경제적이다. |
| 확장성 (Scalability)         | 멀티 프로세서 시스템에서 병렬성이 증가한다. (하나의 프로세스라 Context Switch될 일이 없기 때문에 CPU가 여러개일 때 병렬적으로 사용될 수 있음) |



**정리**

|      | Process                                   | Thread                               |
| ---- | ----------------------------------------- | ------------------------------------ |
| 1    | 실행 중인 프로그램                        | 프로세스의 실행 단위                 |
| 2    | 종료하는데 시간이 걸림                    | 종료하는데 시간이 덜 걸림            |
| 3    | 생성하는데 더 시간이 걸림                 | 생성 시간이 덜 걸림                  |
| 4    | Context전환에 더 많은 시간이 걸림         | Context전환에 소요되는 시간이 줄어듬 |
| 5    | 대화 측면에서 프로세스의 효율성이 떨어짐  | 대화면에서 쓰레드가 더 효율적        |
| 6    | 더 많은 Resource를 소비                   | 적은 Resource 소비                   |
| 7    | 메모리 공유 X                             | 메모리 공유 O                        |
| 8    | heavy-weight process                      | light-weigth process                 |
| 9    | 프로세스 전환 -> 운영체제 인터페이스 사용 | 스레드 전환 ->운영체제 호출 X        |


### 들어가기 전
#### 오름차순을 기준으로 정렬한다.

### 삽입 정렬(insertion sort) 알고리즘 개념 요약
  - 손안의 카드를 정렬하는 방법과 유사하다.
    - 새로운 카드를 기존의 정렬된 카드 사이의 올바른 자리를 찾아 삽입한다.
    - 새로 삽입될 카드의 수만큼 반복하게 되면 전체 카드가 정렬된다.
  - 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교 하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘
  - 매 순서마다 해당 원소를 삽입할 수 있는 위치를 찾아 해당 위치에 넣는다.

### 삽입 정렬(insertion sort) 알고리즘의 구체적인 개념
  - 삽입 정렬은 두 번째 자료부터 시작하여 그 앞(왼쪽)의 자료들과 비교하여 삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘이다.
  - 즉, 두 번째 자료는 첫 번째 자료, 세 번째 자료는 두 번째와 첫 번째 자료, 네 번째 자료는 세 번째, 두 번째, 첫 번째 자료와 비교한 후 자료가 삽입될 위치를 찾는다. 자료가 삽입될 위치를 찾았다면 그 위치에 자료를 삽입하기 위해 자료를 한 칸씩 뒤로 이동시킨다.
  - __처음 Key 값은 두 번째 자료부터 시작한다.__

### 삽입 정렬(insertion sort) 알고리즘의 예제
  - 배열에 8, 5, 6, 2, 4가 저장되어 있다고 가정하고 자료를 오름차순으로 정렬해 보자.
  - ![image](https://user-images.githubusercontent.com/77487962/124349250-2bb53d80-dc29-11eb-89c4-3bc91860e621.png)
 
  - ![image](https://user-images.githubusercontent.com/77487962/124349277-45568500-dc29-11eb-9bab-ee636405417b.png)
  > 1회전: 두 번째 자료인 5를 Key로 해서 그 이전의 자료들과 비교한다.
  > > - Key 값 5와 첫 번째 자료인 8을 비교한다. 8이 5보다 크므로 8을 5자리에 넣고 Key 값 5를 8의 자리인 첫 번째에 기억시킨다.
  - ![image](https://user-images.githubusercontent.com/77487962/124349297-57382800-dc29-11eb-99f6-e91cb24878bf.png)
  > 2회전: 세 번째 자료인 6을 Key 값으로 해서 그 이전의 자료들과 비교한다.
  > > - Key 값 6과 두 번째 자료인 8을 비교한다. 8이 Key 값보다 크므로 8을 6이 있던 세 번째 자리에 기억시킨다.
  > > - Key 값 6과 첫 번째 자료인 5를 비교한다. 5가 Key 값보다 작으므로 Key 값 6을 두 번째 자리에 기억시킨다.
  - ![image](https://user-images.githubusercontent.com/77487962/124349310-6028f980-dc29-11eb-8bbb-47d13ef702d5.png)
  > 3회전: 네 번째 자료인 2를 Key 값으로 해서 그 이전의 자료들과 비교한다.
  > > - Key 값 2와 세 번째 자료인 8을 비교한다. 8이 Key 값보다 크므로 8을 2가 있던 네 번째 자리에 기억시킨다.
  > > - Key 값 2와 두 번째 자료인 6을 비교한다. 6이 Key 값보다 크므로 6을 세 번째 자리에 기억시킨다.
  > > - Key 값 2와 첫 번째 자료인 5를 비교한다. 5가 Key 값보다 크므로 5를 두 번째 자리에 넣고 그 자리에 Key 값 2를 기억시킨다.
  - ![image](https://user-images.githubusercontent.com/77487962/124349330-6dde7f00-dc29-11eb-8d91-05d18a8de357.png)
  > 4회전: 다섯 번째 자료인 4를 Key 값으로 해서 그 이전의 자료들과 비교한다.
  > > - Key 값 4와 네 번째 자료인 8을 비교한다. 8이 Key 값보다 크므로 8을 다섯 번째 자리에 기억시킨다.
  > > - Key 값 4와 세 번째 자료인 6을 비교한다. 6이 Key 값보다 크므로 6을 네 번째 자리에 기억시킨다.
  > > - Key 값 4와 두 번째 자료인 5를 비교한다. 5가 Key 값보다 크므로 5를 세 번째 자리에 기억시킨다. 
  > > - Key 값 4와 첫 번째 자료인 2를 비교한다. 2가 Key 값보다 작으므로 4를 두 번째 자리에 기억시킨다.
  
  - ![image](https://user-images.githubusercontent.com/77487962/124349333-720a9c80-dc29-11eb-9de3-0c434679e591.png)


### 삽입 정렬(insertion sort) JAVA 코드
```
void insertionSort(int[] arr)
{
   for(int index = 1 ; index < arr.length ; index++){ // 1.
      int temp = arr[index];
      int prev = index - 1;
      while( (prev >= 0) && (arr[prev] > temp) ) {    // 2.
         arr[prev+1] = arr[prev];
         prev--;
      }
      arr[prev + 1] = temp;                           // 3.
   }
   System.out.println(Arrays.toString(arr));
}
```

1. 첫 번째 원소 앞(왼쪽)에는 어떤 원소도 갖고 있지 않기 때문에, 두 번째 위치(index)부터 탐색을 시작한다. temp에 임시로 해당 위치(index) 값을 저장하고, prev에는 해당 위치(index)의 이전 위치(index)를 저장한다.
2. 이전 위치(index)를 가리키는 prev가 음수가 되지 않고, 이전 위치(index)의 값이 '1'번에서 선택한 값보다 크다면, 서로 값을 교환해주고 prev를 더 이전 위치(index)를 가리키도록 한다.
3. '2'번에서 반복문이 끝나고 난 뒤, prev에는 현재 temp 값보다 작은 값들 중 제일 큰 값의 위치(index) 를 가리키게 된다. 따라서, (prev+1)에 temp 값을 삽입해준다.

### GIF로 보는 insertion sort
![image](https://raw.githubusercontent.com/GimunLee/tech-refrigerator/master/Algorithm/resources/insertion-sort-001.gif)


### 삽입 정렬(insertion sort) 알고리즘의 특징
#### 장점
  - 알고리즘이 단순하다.
  - 대부분의 원소가 이미 정렬되어 있는 경우, 매우 효율적일 수 있다.
  - 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않는다. => 제자리 정렬(in-place sorting)
  - 안정 정렬(Stable Sort) 이다.
  - Selection Sort나 Bubble Sort과 같은 O(n^2) 알고리즘에 비교하여 상대적으로 빠르다.
#### 단점
  - 평균과 최악의 시간복잡도가 O(n^2)으로 비효율적이다.
  - Bubble Sort와 Selection Sort와 마찬가지로, 배열의 길이가 길어질수록 비효율적이다.

### 삽입 정렬(insertion sort)의 시간복잡도
시간복잡도를 계산한다면
```
최악의 경우(역으로 정렬되어 있을 경우) Selection Sort와 마찬가지로, (n-1) + (n-2) + .... + 2 + 1 => n(n-1)/2 즉, O(n^2) 이다.

하지만, 모두 정렬이 되어있는 경우(Optimal)한 경우, 한번씩 밖에 비교를 안하므로 O(n) 의 시간복잡도를 가지게 된다. 또한, 이미 정렬되어 있는 배열에 자료를 하나씩 삽입/제거하는 경우에는, 현실적으로 최고의 정렬 알고리즘이 되는데, 탐색을 제외한 오버헤드가 매우 적기 때문이다.

최선의 경우는 O(n) 의 시간복잡도를 갖고, 평균과 최악의 경우 O(n^2) 의 시간복잡도를 갖게 된다.
```
- 최선의 경우
    - 비교 횟수
      - 이동 없이 1번의 비교만 이루어진다.
      - 외부 루프: (n-1)번
    - Best T(n) = O(n)
- 최악의 경우(입력 자료가 역순일 경우)
    - 비교 횟수
      - 외부 루프 안의 각 반복마다 i번의 비교 수행
      - 외부 루프: (n-1) + (n-2) + … + 2 + 1 = n(n-1)/2 = O(n^2)
    - 교환 횟수
      - 외부 루프의 각 단계마다 (i+2)번의 이동 발생
      - n(n-1)/2 + 2(n-1) = (n^2+3n-4)/2 = O(n^2)
    - Worst T(n) = O(n^2)

### 정렬 알고리즘 시간복잡도 비교
![image](https://user-images.githubusercontent.com/77487962/124349577-b0ed2200-dc2a-11eb-83c4-cf21aeb35b5b.png)
- 단순(구현 간단)하지만 비효율적인 방법
  - 삽입 정렬, 선택 정렬, 버블 정렬
- 복잡하지만 효율적인 방법
  - 퀵 정렬, 힙 정렬, 합병 정렬, 기수 정렬

### 공간복잡도
- 주어진 배열 안에서 교환(swap)을 통해, 정렬이 수행되므로 O(n) 이다.

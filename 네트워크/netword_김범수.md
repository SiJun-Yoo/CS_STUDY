#  NetWork
**:book: Contents**
+ [1. OSI 7계층]
+ [2. TCP/IP]
+ [3. TCP vs UDP]
  + [3-1. TCP]
  + [3-2. TCP의 3-way handshake 와 4-way handshake]
  + [3-3. UDP]
+ [4. HTTP vs HTTPS]
  + [4-1. HTTP]
  + [4-2. HTTPS]
+ [5. GET vs POST]
  + [5-1. GET]
  + [5-2. POST]
+ [6. Cookie(쿠키) vs Session(세션)]
  + [6-1. Cookie(쿠키)]
  + [6-2. Session(세션)]
+ [7. Rest 와 Restful]
  + [7-1. Rest]
  + [7-2. Rest API]
  + [7-3. Restful]
+ [8. DNS]
  + [8-1. DNS란]
  + [8-2. DNS 구성요소]
  + [8-3. DNS 서버 종류 구분]
  + [8-4. 전체적인 DNS 동작 원리]

## 1. OSI 7계층
  + OSI (Open Systems Interconnection Reference Model)
    + 국제표준화기구(ISO)에서 개발한 모델, 컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명한 것
    + 프로토콜을 기능별로 나눈 것이다.
    + 각 계층은 하위 계층의 기능만을 이요하고, 상위 계층에게 기능을 제공
  + [1. 물리계층 (Physical layer)]
    + 네트워크의 기본 네트워크 하드웨어 전송 기술을 이룬다.
    + 네트워크의 높은 수준의 기능의 논리 데이터 구조를 기초로 하는 필수 계층
    + 전송 단위는 Bit
  + [2. 데이터 링크 계층 (Data link layer)]
    + 장치 간 신호를 전달하는 물리 계층을 이용하여 네트워크 상의 주변 장치들 간 데이터 전송
    + 주소 할당 : 물리 계층으로부터 받은 신호들이 네트워크 상의 장치에 올바르게 안착할 수 있게 함
    + CRC 기반 오류 감지 : 신호가 전달되는 동안 오류가 포함되는지를 감지한다.
      ```
      CRC (Cyclic Redundancy Check)
        * 네트워크 등을 통하여 데이터를 전송할 때 전송된 데이터에 오류가 있는지를 확인하기 위한 체크값 결정 방식
        * 전송 전 데이터의 값에 따른 CRC 값을 붙여 전송, 전송 후 받은 데이터의 값으로 CRC 값 계산 후 비교( 다르면 오류)
      ```
    + 전송 단위는 프레임(Frame)
  + [3. 네트워크 계층 (Network layer)]
    + 라우팅(Routing)을 포함한 패킷 포워딩을 담당하는 계층
    + 라우팅(Routing) : 네트워크 안에서 데이터를 전송할 때 경로를 선택하는 과정
    + 패킷 포워딩(Forwarding) : 라우팅으로 저장된 경로에 패킷을 보내는 작업
    + 전송 단위는 패킷(Packet)
  + [4. 전송 계층 (Transport layer)]
    + 실사용자(end-to-end)가 신뢰성 있는 데이터를 주고 받을 수 있도록 해주는 계층
    + 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해줌
    + 시퀀스 넘버 기반의 오류 제어 방식을 사용
      ```
      시퀀스 넘버
        * 통신과 제어에서 데이터를 관리하기 위해 번호를 부여
        * 해당 번호는 순서 역전 방지, 중복 패킷 방지 등으로 사용
      ```
    + 특정 연결의 유효성을 제어, 일부 프로토콜은 상태 개념이 있고(stateful), 연결 기반(connection oriented)
      <br> -> 패킷들의 전송이 유효한지 확인 후 전송 실패한 패킷들은 다시 전송
    + 전송 단위는 세그먼트(Segment)
  + [5. 세션 계층 (Session layer)]
    + 데이터 통신(송수신)을 관리하기 위한 방법을 제공하는 계층
    + 통신 방법 제공 : 동시 송수신 방식(duplex), 반이중 방식(half-duplex), 전이중 방식(Full duplex)의 통신 제공
    + 체크 포인팅과 종료, 다시 시작 과정 등을 수행
    + TCP/IP 세션을 만들고 없애는 책임을 진다.
  + [6. 표현 계층 (Presentation layer)]
    + 네트워크의 데이터 번역자의 역할(응용 형식 -> 네트워크 형식, 네트워크 형식 -> 응용 형식)
    + MIME 인코딩이나 암호화 등의 동작이 이루어진다.
  + [7. 응용 계층 (Application layer)]
    + 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.

## 2. TCP/IP
  > https://brunch.co.kr/@wangho/6
  + TCP/IP
    + 패킷 통신 방식의 인터넷 프로토콜인 IP (인터넷 프로토콜)와 전송 조절 프로토콜인 TCP (전송 제어 프로토콜)로 이루어짐
    + IP는 복잡한 네트워크 망을 통하여 가장 효율적인 방법으로 데이터의 작은 조각들을 되도록 빨리 보내는 일
    + TCP는 데이터를 잘게 잘라 보내면서 순서가 맞지 않거나 중간에 빠진 부분을 점검하여 다시 요청
  + [1. 네트워크 연결 계층 (Network Access Layer)]
    + 데이터 단위 : 프레임(Frame), 전송 주소 : MAC 주소
    + 물리적으로 데이터가 네트워크를 통해 어떻게 전송되는지를 정의
      + 논리 주소(IP주소 등)이 아닌 물리주소(MAC주소)을 참조해 전송
      <br> MAC 주소(Media Access Control Address) : 컴퓨터의 하드웨어 주소
    + 기본적으로 에러검출 / 패킷의 프레임화 담당
  + [2. 인터넷 계층 (Internet Layer)]
    + 데이터 단위 : 패킷(Packet), 전송 주소 : IP 주소
    + 네트워크상 최종 목적지까지 정확하게 연결되로고 연결성 제공
    + 단말을 구분하기 위해 논리적인 주소(Logical Address) IP를 할당
    + 라우팅(Routing) 기능을 처리
    + 패킷 단위의 데이터 
  + [3. 전송 계층 (Transport Layer)]
    + 데이터 단위 : 세그먼트(Segment), 전송 주소 : 포트(Port)
    + 통신 노드 간의 연결 제어 및 자료 송수신을 담당
  + [4. 응용 계층 (Application Layer)]
    + 데이터 단위 : Data / Message
    + 응용 프로그램(Application)들이 데이터를 교환하기 위해 사용되는 프로토콜
    + 사용자 응용 프로그램 인터페이스를 담당
 
## 3. TCP vs UDP
#### 3-1. TCP
  + TCP (Transmission Control Protocol)
    + 인터넷 상에서 데이터를 메세지의 형태(세그먼트 라는 블록 단위)로 보내기 위해 IP와 함게 사용하는 프로토콜
    + TCP와 IP를 함께 사용하는데, IP는 데이터의 배달을 처리, TCP는 패킷을 추적
    + 연결형 서비스로 가상 회선 방식을 제공
      + 3-way handshaking 과정을 통해 연결을 설정, 4-way handshaking을 통해 연결을 해제
    + 흐름 제어 (Flow Control)
      + 수신측이 송신측보다 데이터 처리 속도가 빠르면 문제없지만, 송신측의 속도가 빠를 경우 문제 발생
      + 수신측에서 제한된 저장 용량 초과한 후 도착하는 데이터는 손실 될 수 있으며, 만약 손실시 불필요한 응답, 데이터 전송이 송수신 측간에 빈번이 발생
      + 데이터를 송신하는 곳과 수신하는 곳의 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우 방지
      + 해결 방법
        + Stop and Wait : 매번 전송한 패킷에 대해 확인 응답을 받아야만 다음 패킷을 전송하는 방법
        + Sliding Window (Go Back N ARQ) : 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인 응답없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어기법
        ```
        * 목적 : 전송은 되었지만, ACK를 받지 못한 byte의 숫자를 파악하기 위해 사용하는 protocol
        (LastByteSent - LastByteAcked <= ReceiveWindowAdvertised)
        마지막에 보내진 바이트 - 마지막에 확인된 바이트 <= 남아있는 공간
        * 동작 방식
          1. 윈도우에 포함되는 모든 패킷을 전송
          2. 그 패킷들의 전달이 확인되는 대로 윈도우를 옆으로 옮김으로써 다음 패킷들을 전송
        ```
    + 혼잡 제어 (Congestion Control)
      + 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지
      + 정보의 소통량이 과다하면 패킷을 조금만 전송하여 혼잡 붕괴 현상이 일어나는 것을 방지
      + 해결 방법
        + AIMD (Additive Increase / Multiplicative Decrease)
        + Slow Start (느린 시작)
        + Fast Retransmit (빠른 재전송)
        + Fast Recovery (빠른 회복)
    + 높은 신뢰성을 보장
    + UDP보다 속도가 느림
    + 전이중(Full-Duplex), 점대점(Point to Point) 방식
      + 전이중
        + 전송이 양방향으로 동시에 일어날 수 있다.
      + 점대점
        + 각 연결이 정확히 2개의 종단점을 가지고 있다.
      + 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다.
      ```
      * 유니캐스팅
        - MAC 주소를 기반으로 상대측 IP주소를 목적지로 하는 일대일 통신 방식
      * 멀티캐스팅
        - UDP 기반
        - 하나 이상의 송신자들이 특정한 하나 이상의 수신자들에게 데이터를 전송하는 방식
      * 브로드캐스팅
        - UDP 기반
        - 로컬 랜상에 붙어있는 모든 네트워크 장비들에게 그들의 의사와 상관없이 모두 보내는 방식
      ```
    + 연속성보다 신뢰성있는 전송이 주요할 때에 사용
### 3-2. TCP의 3-way handshake 와 4-way handshake
  + TCP는 장치들 사이에 논리적인 접속을 성립하기 위하여 연결을 설정하여 신뢰성을 보장하는 연결형 서비스
  + 3-way handshake
    + TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정하는 과정
    + 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장, 실제로 데이터 전달이 시작하기 전에 한 쪽이 다른 쪽이 준비되었음을 알 수 있음
    + 즉, TCP/IP 프로토콜을 이용해서 통신을 하는 응용 프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미
    + 동작 과정
      + A 프로세트(Client)가 B 프로세스(Server)에 연결을 요청
        + 1. A -> B : SYN
          + 접속 요청 프로세스 A가 연결 요청 메시지 전송(SYN)
          + 송신자가 최초로 데이터를 전송할 때 시퀀스 넘버(Sequence Number)를 임의의 랜덤 숫자로 지정, SYN 플래그 비트를 1로 설정한 세그먼트 전송
          + PORT 상태 : A - CLOSED, B : LISTEN
        + 2. B -> A : SYN + ACK
          + 접속 요청을 받은 프로세스 B가 요청을 수락했으며, 접속 요청 프로세스인 A도 포트를 열어 달라는 메시지 전송 (SYN + ACK)
          + 수신자는 Acknowledgement Number 필드를 (Sequence Number + 1)로 지정, SYN과 ACK 플래그 비트를 1로 설정한 세그먼트를 전송
          + PORT 상태 : A : CLOSED, B : SYN_RCV
        + 3. A -> B : ACK
          + 마지막으로 접속 요청 프로세스 A가 수락 확인을 보내 연결을 맺음 (ACK)
          + 데이터 전송이 가능
          + PORT 상태 : A : ESTABLISHED, B : ESTABLISHED
  + 4-way handshake
    + TCP의 연결을 해제하는 과정
      + A 프로세스(Client)가 B 프로세스(Server)에 연결 해제를 요청
        + 1. A -> B : FIN
          + 프로세스 A가 연결을 종료하겠다는 FIN 플래그 전송
          + 프로세스 B가 FIN 플래그로 응답하기 전까지 연결 유지
        + 2. B -> A : ACK
          + 프로세스 B는 일단 확인 메시지 전송 자신의 통신이 끝날 때까지 기다림(이 상태가 TIME_WAIT 상태)
          + 수신자는 Acknowledgement Number 필드를 (Sequence Number + 1)로 지정하고, ACK 플래그 비트를 1로 설정한 세그먼트 전송
          + 자신이 전송할 데이터가 남아있다면 이어서 전송
        + 3. B -> A : FIN
          + 프로세스 B가 통신이 끝나면 연결 종료 요청에 합의한다는 의미로 프로세스 A에게 FIN 플래그 전송
        + 4. A -> B : ACK
          + 프로세스 A는 확인했다는 메시지 전송
  ```
  포트(Port) 상태 정보
    - CLOSED : 포트가 닫힌 상태
    - LISTEN : 포트가 열린 상태로 연결 요청 대기
    - SYN_RCV : SYNC 요청을 받고 상대방의 응답을 기다리는 중
    - ESTABLISHED : 포트 연결 상태
  ```
### 3-3. UDP
  + UDP (User DAtagram Protocol)
    + 데이터를 데이터그램 단위로 처리하는 프로토콜
    + 비연결형 서비스로 데이터그램 방식을 제공
      + 연결을 위해 할당되는 논리적인 경로가 없다.
      <br> -> 각각의 패킷은 다른 경로로 전송되고, 각각의 패킷은 독립적인 관계를 지니게 된다.
      <br> -> 데이터를 서로 다른 경로로 독립적으로 처리한다.
    + 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않음
    + UDP 헤더의 CheckSum 필드를 통해 최소한의 오류만 검출
    <br> `CheckSum : 중복 검사의 한 형태, 송신된 자료의 무결성을 보호하는 단순한 방법`
    + 신뢰성이 낮다.
    + TCP보다 속도가 빠르다.
    + 신뢰성보다는 연속성이 중요한 서비스, 예를 들면 실시간 서비스(Streaming)에 사용
   ```
    참고
      - UDP와 TCP는 각각 별도의 포트 주소 공간을 고나리하므로 같은 포트 번호 사용해도 무방
      - 같은 모듈(TCP or UDP) 내에서도 클라이언트 프로그램에서 동시에 여러 커넥션을 확립한 경우 서로 다른 포트 번호 동적 할당
   ```
## 4. HTTP vs HTTPS
### 4-1. HTTP (HyperText Transfer Protocol)
  + HTTP 프로토콜
    + 개념
      + 웹 상에서 클라이언트와 서버 간에 요청/응답(Request/Response)으로 정보를 주고 받을 수 있는 프로토콜
    + 특징
      + 주로 HTML 문서를 주고 받는데 사용
      + TCP와 UDP를 사용, 80번 포트 사용
      + 비연결(Connectionless)
        + 클라이언트가 요청을 서버에 보내고 서버가 적절한 응답을 클라이언트에 보내면 바로 연결이 끊긴다.
      + 무상태(Stateless)
        + 연결을 끊는 순간 클라이언트와 서버의 통신은 끝나며 상태 정보를 유지하지 않는다. ex) 화면 이동 시 다시 로그인을 하여야 됨(쿠키에 저장하기 전)
    ```
      동작 과정 ex)웹브라우저에 google.com 치면 일어나는 과정
        1. 사용자가 웹 브라우저에 URL 주소 입력
        2. DNS 서버에 웹 서버의 호스트 이름을 IP 주소로 변경 요청
        3. 웹 서버와 TCP 연결 시도(3-way handshake)
        4. 클라이언트가 서버에 요청(Request)
        5. 서버가 클라이언트에게 응답(Response)
        6. 서버 클라이언트간 연결 종료(4-way handshake)
        7. 웹 브라우저가 웹 문서 출력
    ```
### 4-2. HTTPS (HyperText TRansfer Protocol Secure)
  + HTTPS 프로토콜
    + 개념
      + 웹 통신 프로토콜 HTTP의 보안이 강화된 버전의 프로토콜
    + 특징
      + HTTPS의 기본 TCP/IP 포트 443번 포트 사용
      + 소켓 통신에서 일반 텍스트를 이용하는 대신, 웹 상에서 정보를 암호화하는 SSL이나 TLS 프로토콜을 통해 세션 데이터 암호화
      ```
      TLS(Transport Layer Security), SSL(Secure Socket Layer)
        - TLS 프로토콜은 SSL 프로토콜에서 발전한 것이다.
        - 개인 정보 및 금융 정보를 포함한 전송되는 모든 정보를 열람하거나 훔치는 것을 방지
      ```
      + 데이터의 적절한 보호를 보장한다.
        + 보호 수준은 웹 브라우저에서의 구현 정확도와 서버 소프트웨어, 지원하는 암호화 알고리즘에 따라 다름
      + 금융 정보, 메일 등 중요한 저옵를 주고받는 것은 HTTPS, 아무나 봐도 되는 내용은 HTTP를 사용
    ```
    HTTPS가 필요한 이유?
      - 클라이언트인 웹 브라우저가 서버에 웹 페이지나 이미지 정보 요청하면 서버가 응답하여 요구에 따른 정보 제공
      - 웹 페이지(HTML)은 텍스트이고, HTTP를 통해 정보 교환
      - 정보에 주민등록번호나 비밀번호와 같은 정보가 포함된 상태로 중간에 제3자가 정보를 가로채면 보안 문제 발생
      - 중간에 볼 수 없도록 정보를 암호화하는 방법인 HTTPS를 사용
    ```
    - HTTPS의 장단점
      - 장점
        - 네트워크 상에서 열람, 수정이 불가능하므로 안전
      - 단점
        - 암호화를 하는 과정에 웹 서버에 부하를 준다.
        - 설치 및 인증서를 유지하는데 추가 비용 발생
        - HTTP에 비해 느리다.
        - 인터넷 연결이 끊긴 경우 재인증 시간이 소요
          - HTTP는 비연결형으로 웹 페이지를 보는 도중 인터넷 연결이 끊겻다가 다시 연결되어도 페이지를 계속 볼 수 있다.
          - HTTPS는 소켓(데이터를 주고 받는 경로) 자체에서 인증하기 때문에 끊기면 소켓도 끊어져서 다시 인증이 필요
    ```
    동작 과정
      1. 클라이언트가 생성한 랜덤 데이터 서버에 전송
      2. 서버가 생성한 랜덤 데이터 클라이언트에 전송
      3. 클라이언트 인증 확인
        3-1. 서버로 부터 받은 인증서가 CA에 의해 발급되었는지 본인이 가지고 있는 목록에서 확인
        3-2. 있다면 CA 공개키로 인증서 복호화
        3-3. 클라이언트, 서버 각각의 랜덤 데이터를 조합하여 pre master secret 값 생성(데이터 송수신 시 대칭키 암호화에 사용할 키)
        3-4. pre master secret 값을 공개키 방식으로 서버 전달(공개키는 서버로부터 받은 인증서에 포함)
        3-5. session key 생성
      4. 서버 인증 확인
        4-1. 서버는 비공개키로 복호화하여 pre master secret 값 취득(대칭키 공유 완료)
        
      ```
## 5. GET 메서드와 POST 메서드
### HTTP 프로토콜을 이용해서 서버에 데이터(요청 정보)를 전달할 때 사용하는 방식
#### 5-1.GET 메서드 방식
+ 개념
  + 정보를 조회하기 위한 메서드
  + 서버에서 어떤 데이터를 가져와서 보여주기 위한 용도의 메서드
  + 가져오는 것(Select)
+ 사용 방법
  + URL의 끝에 '?'가 붙고, 요청 정보가 (key=value)형태의 쌍을 이루어 ?뒤에 이어서 붙어 서버로 전송한다.
  + 요청 정보가 여러 개일 경우에는 '&'로 구분한다.
  + Ex) www.urladdress.xyz?name1=value1&name2=value2
+ 특징
  +  URL에 요청 정보를 붙여서 전송한다.
  +  URL에 요청 정보가 이어붙기 때문에 길이 제한이 있어서 대용량의 데이터를 전송하기 어렵다.
      +  한 번 요청 시 전송 데이터(주솟값 + 파라미터)의 양은 255자로 제한된다.(HTTP/1.1은 2048자)
  +  요청 정보를 사용자가 쉽게 눈으로 확인할 수 있다.
      +  POST 방식보다 보안상 취약하다.
  +  HTTP 패킷의 Body는 비어 있는 상태로 전송한다.
      +  즉, Body의 데이터 타입을 표현하는 'Content-Type' 필드도 HTTP Request Header에 들어가지 않는다.
  +  POST 방식보다 빠르다.
      +  GET 방식은 캐싱을 사용할 수 있어, GET 요청과 그에 대한 응답이 브라우저에 의해 캐쉬된다.
#### 5-2.POST 메서드 방식
+ 개념
  + 서버의 값이나 상태를 바꾸기 위한 용도의 메서드
    + 수행하는 것(Insert, Update, Delete)
+ 사용 방법
  + 요청 정보를 HTTP 패킷의 Body 안에 숨겨서 서버로 전송한다.
  + Request Header의 Content-Type에 해당 데이터 타입이 표현되며, 전송하고자 하는 데이터 타입을 적어주어야 한다.
  + Default: application/octet-stream
  + 단순 txt의 경우: text/plain
  + 파일의 경우: multipart/form-date
+ 특징
  + Body 안에 숨겨서 요청 정보를 전송하기 때문에 대용량의 데이터를 전송하기에 적합하다.
  + 클라이언트 쪽에서 데이터를 인코딩하여 서버로 전송하고, 이를 받은 서버 쪽이 해당 데이터를 디코딩한다.
  + GET 방식보다 보안상 안전하다.
```
Q. 조회하기 위한 용도 POST가 아닌 GET 방식을 사용하는 이유?
  1. 설계 원칙에 따라 GET 방식은 서버에게 여러 번 요청을 하더라도 동일한 응답이 돌아와야 한다. (Idempotent, 멱등)
    GET 방식은 가져오는 것(Select) 으로, 서버의 데이터나 상태를 변경시키지 않아야 한다.
    Ex) 게시판의 리스트, 게시글 보기 기능
    예외) 방문자의 로그 남기기, 글을 읽은 횟수 증가 기능
    POST 방식은 수행하는 것 으로, 서버의 값이나 상태를 바꾸기 위한 용도이다.
    Ex) 게시판에 글쓰기 기능
  2. 웹에서 모든 리소스는 Link할 수 있는 URL을 가지고 있어야 한다.
    어떤 웹페이지를 보고 있을 때 다른 사람한테 그 주소를 주기 위해서 주소창의 URL을 복사해서 줄 수 있어야 한다.
    즉, 어떤 웹페이지를 조회할 때 원하는 페이지로 바로 이동하거나 이동시키기 위해서는 해당 링크의 정보가 필요하다.
    이때 POST 방식을 사용할 경우에 값(링크의 정보)이 Body에 있기 때문에 URL만 전달할 수 없으므로 GET 방식을 사용해야한다. 
    그러나 글을 저장하는 경우에는 URL을 제공할 필요가 없기 때문에 POST 방식을 사용한다.
```      
### 6.쿠키와 세션
+ HTTP 프로토콜의 특징
  + 비연결 지향(Connectionless)
    + 클라이언트가 request를 서버에 보내고, 서버가 클라이언트에 요청에 맞는 response를 보내면 바로 연결을 끊는다.
  + 상태정보 유지 안 함(Stateless)
    + 연결을 끊는 순간 클라이언트와 서버의 통신은 끝나며 상태 정보를 유지하지 않는다.
+ 쿠키와 세션의 필요성
  + HTTP 프로토콜은 위와 같은 특징으로 모든 요청 간 의존관계가 없다.
```
즉, 현재 접속한 사용자가 이전에 접속했던 사용자와 같은 사용자인지 아닌지 알 수 있는 방법이 없다.
계속해서 연결을 유지하지 않기 때문에 리소스 낭비가 줄어드는 것이 큰 장점이지만, 통신할 때마다 새로 연결하기 때문에 클라이언트는 매 요청마다 인증을 해야 한다는 단점이 있다.
이전 요청과 현재 요청이 같은 사용자의 요청인지 알기 위해서는 상태를 유지해야 한다.
HTTP 프로토콜에서 상태를 유지하기 위한 기술로 쿠키와 세션이 있다.
```
#### + 6-1.쿠키(Cookie)란?
  + 개념
    + 클라이언트 로컬에 저장되는 키와 값이 들어있는 파일이다.
    + 이름, 값, 유효 시간, 경로 등을 포함하고 있다.
    + 클라이언트의 상태 정보를 브라우저에 저장하여 참조한다.
  + 구성 요소
    + 쿠키의 이름(name)
    + 쿠키의 값(value)
    + 쿠키의 만료시간(Expires)
    + 쿠키를 전송할 도메인 이름(Domain)
    + 쿠키를 전송할 경로(Path)
    + 보안 연결 여부(Secure)
    + HttpOnly 여부(HttpOnly)
  + 쿠키 사용 예
    + 아이디, 비밀번호 저장
    + 쇼핑몰 장바구니

#### + 6-2.세션(Session)이란?
  + 개념
    + 일정 시간 동안 같은 브라우저로부터 들어오는 요청을 하나의 상태로 보고 그 상태를 유지하는 기술이다.
```
즉, 웹 브라우저를 통해 서버에 접속한 이후부터 브라우저를 종료할 때까지 유지되는 상태이다.
```
  + 세션 사용 예
    + 로그인
    ```
    세션도 쿠키를 사용하여 값을 주고받으며 클라이언트의 상태 정보를 유지한다.
    즉, 상태 정보를 유지하는 수단은 쿠키 이다.
    ```
+ 쿠키와 세션의 차이점
  + 저장 위치
    + 쿠키 : 클라이언트
    + 세션 : 서버
  + 보안
    + 쿠키 : 클라이언트에 저장되므로 보안에 취약하다.
    + 세션 : 쿠키를 이용해 Session ID만 저장하고 이 값으로 구분해서 서버에서 처리하므로 비교적 보안성이 좋다.
  + 라이프사이클
    + 쿠키 : 만료시간에 따라 브라우저를 종료해도 계속해서 남아 있을 수 있다.
    + 세션 : 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제된다.
  + 속도
    + 쿠키 : 클라이언트에 저장되어서 서버에 요청 시 빠르다.
    + 세션 : 실제 저장된 정보가 서버에 있으므로 서버의 처리가 필요해 쿠키보다 느리다.      
      
# WebServer?
> 
클라이언트로 부터 Http요청을 받아 HTML,CSS,img와 같은 정적 컨텐츠를 제공

* Apache,Nginx가 대표적인 웹서버
* WAS에게 동적인 컨텐츠 제공을 위한 요청을 전달함
* Request를 WAS에게 보내고 WAS가 처리한 데이터를 클라이언트에게 Response한다.

# WAS?
>
Request에 대한 비즈니스 로직들을 처리해 동적인 컨텐츠를 제공

* Tomcat이 대표적인 WAS
* 웹컨테이너 || 서블릿 컨테이너라고 불린다.
* 업무를 처리하는 비즈니스 로직을 수행함
* 프로그램 실행환경과 DB접근을 제공
* 여러개의 트랜잭션 관리
![](https://images.velog.io/images/dbtlwns/post/1244caf2-fdb6-420c-91a4-73c3bd313566/image.png)

# 왜 구분하나?

* 부하방지
WebServer를 통해 정적인 파일들을 Application Server까지 가지않고 앞단에서 빠르게 보내줄수 있다. 또한 WebServer하나에 WAS여러개를 연결하여(로드밸런싱) 부하를 방지할 수 있다.

* 보안 강화
SSL에 대한 암복호화 처리에 WEBSERVER를 사용할 수 있다.

* 무중단 운영
WAS에서 오류가 발생한다면 이용하지 못하도록 한 후 WAS를 재시작하여 사용자는 오류를 느끼지 못하도록 WebServer에서 처리할 수 있다.

* 여러 웹 어플리케이션 서비스 제공
하나의 서버에서 PHP,JAVA Application을 함께 사용가능

* 기타
접근 IP 제어, 여러 대의 서버에서의 세션 관리등을 WebServer에서 처리하면 효율적이다.

# 구조

![](https://images.velog.io/images/dbtlwns/post/05347a25-ec7a-4dec-bfbc-145f9d96250e/image.png)
1. Web Server는 클라이언트로부터 HTTP 요청을 받는다.
2. Web Server는 클라이언트의 요청(Request)을 WAS에 보낸다.
3. WAS는 관련된 Servlet을 메모리에 올린다.
4. WAS는 web.xml을 참조하여 해당 Servlet에 대한 Thread를 생성한다. 
5. HttpServletRequest와 HttpServletResponse 객체를 생성하여 Servlet에 전달한다.
5-1. Thread는 Servlet의 service() 메서드를 호출한다.
5-2. service() 메서드는 요청에 맞게 doGet() 또는 doPost() 메서드를 호출한다.
6. doGet() 또는 doPost() 메서드는 인자에 맞게 생성된 적절한 동적 페이지를 Response 객체에 담아 WAS에 전달한다.
7. WAS는 Response 객체를 HttpResponse 형태로 바꾸어 Web Server에 전달한다.
8. 생성된 Thread를 종료하고, HttpServletRequest와 HttpServletResponse 객체를 제거한다.
# 참고한 사이트
[gmlwjd9405님 블로그](https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html)
[위키백과](https://ko.wikipedia.org/wiki/%EC%9B%B9_%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98_%EC%84%9C%EB%B2%84)
      
 # CORS (Cross Origin Resource Sharing, 교차 출처 리소스 공유)

+ CORS란

  + 추가적인 HTTP 헤더를 사용해서 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제

+ 출처 (Origin)

  + 요청이 시작된 서버의 위치를 나타내는 문구

    + URL 구조에서 Protocol, Host, Port까지 모두 합친 것을 의미

    > 내가 Naver 로그인 서버로 로그인 요청을 한다고 가정한다.
    > ![](https://images.velog.io/images/qjatn1009/post/ace03f16-c7fa-4d87-a707-4b43e824b506/image.png)
    >
    > 이때 서버 IP는 2개가 존재
    >
    > 1. Client 서버
    > 2. 로그인 API 서버
    >
    > 예를 들어 Client 서버는 http://client:80/ 이고, 로그인 서버는 http://login:3000/이라고 가정하면,
    >
    > 그럼 클라이언트 서버가 로그인 서버에게 HTTP 요청을 보낼 때 Origin이 다르다고 표현한다.
    >
    > 이를 `Cross Origin`이라고 하고, 만약 로그인 서버와 내부 통신을 한다면 `Same Origin`이라고 한다.

  + 같은 출처 vs 다른 출처
    + 기준 Origin : `https://beomy.github.io/tech/`
  
   ![](https://images.velog.io/images/qjatn1009/post/7818a197-d3f5-4f0e-99fa-ada9dd865548/image.png)

#  SOP (Same Origin Policy, 동일 출처 정책)

+ SOP란

  + 동일한 출처의 Origin만 리소스를 공유할 수 있도록하는 정책

+ SOP의 장점

  + 동일 출처 정책을 지키면 외부 리소스를 가져오지 못해 불편하지만, XSS나 XSRF 등의 보안 취약점을 방어할 수 있다.

    >**XSS (Cross Site Scripting, 사이트 간 스크립팅)** : 관리자가 아닌 권한이 없는 사용자가 웹 사이트에 스크립트를 삽입하는 공격
    >
    >**XSRF (Cross Site Request Forgery, 사이트 간 요청 위조) ** :  사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 웹사이트에 요청하게 하는 공격

    

# CORS 동작 원리

+ CORS의 동작 방식은 단순 요청 방법과 예비 요청을 먼저 보내는 방법 2가지 방법이 있다.

  + ### Simple Request

    + 서버에게 바로 요청을 보내는 방법

    > 1. HTTP 통신 헤더인 `Origin` 헤더에 요청을 보내는 곳의 정보를 담고 서버로 요청을 보낸다.
    > 2. 이후 서버는 `Access-Control-Allow-Origin` 헤더에 허용된 `Origin`이라는 정보를 담아 보낸다.
    > 3. 클라이언트는 헤더의 값과 비교해 정상 응답임을 확인하고 지정된 요청을 보낸다.
    > 4. 서버는 요청을 수행하고 200, OK 코드를 응답한다.

  + ### Preflight Request

    + 서버에 예비 요청을 보내서 안전한지 판단한 후 요청을 보내는 방법

    > 1. `OPTIONS` 메서드로 서버에 예비 요청을 먼저 보낸다.
    > 2. 서버는 예비 요청에 대한 응답으로 `Access-Control-Allow-Origin` 헤더를 포함한 응답으로 클라이언트에 보낸다.
    > 3. `Simple Request` 와 같은 방법으로 수행

### REST
- REST란 Representational State Transfer 의 약자로 소프트웨어 프로그램 개발의 아키텍처의 한 형식
- Representational State Transfer- '대표적인 상태 전달' 
  - '자원(resource)의 대표(representation)에 의한 상태 전달'
  - 그럼 '자원의 대표'와 '상태 전달'이 무슨 뜻 일까?

### 자원의 대표
  - 여기서 '자원'이란 뜻은 넓은 의미로 해당 소프트웨어가 관리하는 모든 것이 될 수 있습니다. 
    - ```문서```가 될 수도 있고 ```그림```이 될 수도 있고 ```데이터```가 될 수도 있고 심지어 ```해당 소프트웨어 자체```가 될 수도 있습니다. 
    - 예를 들어 DB에 학생 명부가 저장되어 있다고 한다면 이 학생들의 정보가 자원이 됩니다. 
  - 그리고 '자원의 대표'의 의미는 그 자원을 대표하기 위한 이름을 뜻합니다. 
    - 학생데이터를 대표하기 위한 이름은 무엇이 좋을까요? 물론 학생(students:복수형을 사용합니다)입니다. 
    - 학생 전체 명부가 아니라 명부상의 한 학생에 대한 자원을 얻고자 한다면 대표이름과 한 학생을 **특정할 수 있는 값(id 등)** 이 사용됩니다.

### 상태 전달
  - 데이터가 요청되어지는 시점에서 자원의 상태(정보)를 전달하는 것을 뜻합니다. 
  - 데이터를 요청하는 시점에 따라 데이터가 바뀔 수도 있기 때문에 **'상태'** 라는 표현을 쓴 것이라 추측해 봅니다. 
  - 프로그램이 학생 명부 전체 리스트를 요청받으면 요청받은 시점의 '상태' **즉, 데이터**를 전달하게 됩니다. 
  - 또한 새로운 학생 명부 '상태'를 프로그램에 전달하여 해당 자원을 수정할 수도 있습니다.

```
이처럼 자원을 이름으로 구분하고 해당 자원의 상태를 주고 받는 모든 것이 REST라고 할 수 있지만, 
일반적으로 REST라고 하면 좁은 의미로 HTTP를 통해 CRUD를 실행하는 API를 뜻합니다.
```
```
HTTP 프로토콜을 이용하기 때문에 URL(route)를 통해 자원을 특정짓고 HTTP Verbs를 통해 할일(CRUD)을 지정합니다. 
또한 JSON 혹은 XML를 통해 데이터를 주고 받는 것이 일반적입니다.
```

위 정의에 더하여 **REST를 정의**하기 위한 조건들은 다음과 같습니다.

1. **'클라이언트-서버' 구조** : 자원(resource)이 있는 쪽이 서버가 되며, 요청을 하는 쪽이 해당 서버에 대한 클라이언트가 됩니다.
2. **무상태(Stateless)** : '서버'는 각각의 요청을 완전히 별개의 것으로 인식하고 처리해야하며, 이전 요청이 다음 요청의 처리에 연관이 되어서는 안됩니다. 
즉 서버 session을 사용해선 안됩니다. 
서버의 처리 방식에 일관성을 부여하고 서버의 부담을 줄이기 위한 것으로 보입니다.
3. **캐시 처리 가능(Cacheable)** : 대량의 요청을 효율적으로 처리하기 위해 캐시가 요구됩니다.
4. **계층화(Layered System)**
5. **Code on demand (optional)**
6. **인터페이스 일관성**

### RESTful
```
REST는 위 정의들을 구현하는 방식에 제약을 두지 않기 때문에 구체적인 가이드라인이 없습니다. 
RESTful은 REST의 비공식적 구현 가이드입니다. 반드시 따라야 하는 법칙을 만들어서 공표한 것이 아니라 여러 개발자들이 비공식적으로 의견을 제시한 것들의 모음으로. 
즉 개발자마다 생각하는 RESTful의 내용이 다를 수도 있습니다.
```
RESTful 중 가장 대표적이며 보편적인 규칙이 확고하게 정해진 **RESTful routing**입니다. 
참고로 이 외의 RESTful 에는 **header의 사용, return 구조, error code의 사용법** 등이 있습니다.


|CRUD|HTTPverbs|Route|
|------|---|---|
resource들의 목록을 표시|GET|/resource
resource 하나의 내용을 표시|GET|/resource/:id
resource를 생성|POST|/resource
resource를 수정|PUT|/resource/:id
resource를 삭제|DELETE|/resource/:id
- resource는 영어 복수형으로 적습니다
- :id는 하나의 특정한 resource를 나타낼 수 있는 **고유의 값**입니다

### 예제
- student resource(데이터)를 관리하는 API를 생각해봅시다. student resource는 id, 이름, 수강하고 있는 과목들의 정보를 가지고 있습니다. 아래는 student resource의 예입니다.
```
{
  "id": 1,
  "firstName": "Tyrion",
  "lastName": "Lannister",
  "classes": [
    {"id": 1, "name": "History of Westeros"}, 
    {"id": 2, "name": "Brewing"}, 
    {"id": 3, "name": "High Valyrian 101"}
  ]
}
```
- 이제 이러한 데이터를 DB에 생성(Create)하고, 호출(Read)하고, 수정(Update)하고, 삭제(Delete)하는 CRUD route를 구상해 봅시다.

  - [POST] /students : 새 student를 등록
  - [GET] /students : 전체 student list를 호출
  - [GET] /students/1 : 1번 student를 호출
  - [PUT] /students/1 : 1번 student의 정보를 수정
  - [DELETE] /students/1 : 1번 student의 정보를 삭제

```
검색을 하기 위해서는 query를 사용합니다. 
Query_이름=Query_값의 형태로 url을 통해 전달되는 정보들을 query라고 합니다. 
url 뒤에 '?'를 붙인 후 query를 전달하며, 하나 이상의 query를 전달하기 위해서는 query들 사이에 '&'를 사용합니다. 
성이 "Lannister"인 학생들을 검색하는 API의 주소는 [GET] /students?lastName=Lannister 로 설정할 수 있습니다. 
물론 [GET] /students와는 별개로 해당 route을 처리하는 코드를 만들어 주어야 합니다.
```

- RESTful하지 못한 예:
```
CRUD(생성,조회,수정,삭제)기능을 모두 POST로만 처리하는 API
Route에 resource, id 외 정보가 들어가는 경우 (예를 들어 [POST] /students/update -> 이 route을 RESTful하게 고치면 [PUT] students/:id 입니다.)
```


### RESTful API의 장점은?
1. 정해진 규칙대로 routing 주소를 만들기 때문에 route 이름을 짓는 수고를 덜 수 있고, 통일성이 있습니다. 
  1-1. 한 회사에 두개의 개발팀이 있습니다. 한 팀은 학생을 관리하는 API를 만들고, 다른 한팀은 교사를 관리하는 API를 만듭니다. 
  1-2. 이때 두팀 모두 RESTful하게 API를 만들면 "students", "teachers"라는 resource 명을 제외한 나머지 API주소가 동일하게 됩니다. 
  1-3. 만약 두팀이 RESTful하지 않게 API주소를 만든다면, 새로운 학생, 교사를 추가하는 API 주소는 /CreateStudent, /NewTeacher, /CreateNewStudent, /NewTeacher 등 다양하게 될 수 있다.
  1-4. 나중에 양쪽 팀의 API를 동시에 사용하는 프로그램을 만드는 경우 이러한 비일관성은 불필요한 혼란을 불러올 수 있습니다.

2. API의 확장이 쉽습니다. 
  2-1.학생 API에서 과목을 관리하는 API를 추가하는 경우, 
  2-2.[POST] students/:id/classes, [DELETE] students/:id/classes/:id 등과 같이 만들 수 있습니다. 
  2-3.비 RESTful의 경우, 이 기능을 가지는 route의 주소이름을 따로 지어줘야 하는데.. 이름짓는데 시간과 노력이 들어가며, 그렇게 정해진 이름 역시 1번의 문제를 고스란히 가집니다.

```
**통일성과 확장성**이 RESTful API의 장점입니다. 
정해진 규칙에 따라 API 주소, request구조, return 구조를 만들기 때문에 개발팀이 바뀌거나 하는 경우에도 혼란을 줄일 수 있습니다.
```      
      
      
      
## 8. DNS
### 8-1. DNS 란?
```
DNS(Domain Name System)은 범국제적 단위로 웹사이트 IP주소와 도메인 주소를 이어주는 환경 시스템이다.
```
#### 등장배경
1. 인터넷 표준 프로토콜은**TCP/IP**이다.
2. TCP/IP 프로토콜을 사용하는 네트워크 안에서 **Host들을 식별하기 위한 목적으로 IP 주소를 사용**한다.
3. 사람의 경우 숫자보다 문자를 사용하는 것이 더 편하기 때문에 **도메인 이름을 사용하여 Host들을 식별**한다.
4. 도메인 이름을 사용하는 경우에도 최종적으로 **IP주소를 알고 있어야 상대방 장비와 연결이 가능**하다.
5. 네트워크에서 **도메인이나 호스트 이름을 숫자로 된 IP 주소로 해석**해 주는 TCP/IP Network Service인 DNS가 등장하였다. 

#### DNS 포트 번호
```
TCP와 UDP 포트 53번을 사용한다.
```
- TCP : zone Transfer(영역 전송)와 512byte를 초과하는 DNS패킷을 전송해야할 경우 사용
- UDP : 일반적인 DNS조회를 할 경우 사용한다.


 ### 8-2. DNS의 구성 요소
 ![DNS계층 구조](https://user-images.githubusercontent.com/77487962/128623729-4aae8032-a908-44e3-9bce-583541448727.PNG)
 1. 도메인 네임 스페이스(Domain Name Space)
    - DNS가 저장,관리하는 계층적 구조를 의미한다.
    - 최상위에 루트 DNS 서버가 존재하고, 그 하위로 인터넷에 연결된 모든 노드(네모 표시)가 연속해서 이어진계층 구조로 구성되어 있다.
    - PC에서 사용하는 디렉토리 구조와 유사함을 알 수 있는데, 각 레벨(Top level, Second level 등)의 도메인은 그 하위 도메인 에 관한 정보를 관리하는 구조이다. (계층적 구조)
 2. 네임 서버(Name Server)
    - 문자열로 표현된 도메인 이름을 실제 컴퓨터가 통신할 때 사용하는 숫자로 표현된 IP 주소로 변환시켜 주기 위해서는 도메인 네임 스페이스의 트리 구조 에 대한 정보가 필요하며, 이러한 정보를 가지고 있는 서버를 네임 서버라고 한다.

    - 도메인 이름을 IP 주소로 변환하는 것을 네임 서비스라고 한다.

    - 리졸버(Resolver)로부터 요청 받은 도메인 이름에 대한 IP 정보를 다시 리졸버로 전달해주는 역할을 수행한다.
     

    - Primary Name Server: 는 해당 도메인을 관리하는 주 네임 서버이다.

    - Secondary Name Server: 는 primary 네임 서버 의 고장 등의 이유로 동작하지 못하는 경우 이를 대신하여 네임 서버 역할을 수행하는 서버이고 주기적으로 Primary 네임 서버로부터 정보를 받아와 자신의 정보를 갱신하여 전체 네임 서버의 정보가 일관성 있게 유지 및 관리된다.
 3. 리졸버(Resolver)
    - 웹 브라우저와 같은 DNS 클라이언트의 요청을 네임 서버로 전달하고 네임 서버로부터 정보(도메인 이름과 IP 주소)를 받아 클라이언트에게 제공하는 기능을 수행한다.

    - 하나의 네임 서버 에게 DNS 요청을 전달하고 해당 서버에 정보가 없으면 다른 네임 서버에게 요청을 보내 정보를 받아 온다.

    - 수많은 네임 서버에 접근하여 사용자로부터 요청 받은 도메인의 IP 정보를 조회하는 기능을 수행할 수 있어야 한다.
  
 4. 스터브 리졸버(Stub Resolver)
    - 리졸버의 모든 기능을 PC와 같은 클라이언트 호스트에 구현하는 것은 단말 시스템 자원의 한 계와 같은 제약이 있다.

    - 리졸버의 대부분의 기능을 DNS 서버에 구현하고, 클라이언트 호스트에는 리졸버의 단순한 기능만을 지닌 리졸버 루틴을 구현한것이다.

    - 스터브 리졸버는 수 많은 네임 서버의 구조를 파악할 필요 없이 리졸버가 구현된 네임 서버의 IP 주소만 파악하면 된다.

    - 도메인에 대한 질의를 받은 스터브 리졸버는 설정된 네임 서버로 DNS 질의를 전달하고 네임 서버로부터 최종 결과를 응답 받아 웹 브라우저로 전달하는 인터페이스 기능만을 수행한다.

### 8-3. DNS 서버 종류 구분
- 물론, DNS 서버가 초고성능으로 세상에 단 하나만 있다면 위 내용 그대로 이해하면 되겠지만, 그렇게 간단하지만은 않음. 
- 일단 도메인 수가 넘모 많기 때문에, DNS 서버 종류를 계층화해서 단계적으로 처리한다는 게 골자라고 보면 될 것 같음. 
- 특히, 도메인의 총 관리는 ICANN에서 하기 때문에, DNS 서버도 최상위 도메인에서 개인 도메인의 서브 도메인까지 도메인 이름의 분류와 마찬가지로 디렉토리/계층 형태로 구분된다는 걸 생각하면 더 쉽게 이해할 수 있을 거라고 봄.
      
![DNS 서버 종류](https://user-images.githubusercontent.com/77487962/128623857-5426aa3d-b58f-4e2f-81b7-06ed76733c42.PNG)


   1. Root DNS Server: ICANN이 직접 관리하는 절대 존엄 서버로, TLD DNS 서버 IP들을 저장해두고 안내하는 역할을 함.
   2. TLD(최상위 도메인) DNS Server: 도메인 등록 기관(Registry)이 관리하는 서버로, Authoritative DNS 서버 주소를 저장해두고 안내하는 역할을 함. 어떤 도메인 묶음이 어떤 Authoritative DNS Server에 속하는지 아는 이유는 도메인 판매 업체(Registrar)의 DNS 설정이 변경되면 도메인 등록 기관(Registry)으로 전달이 되기 때문임.
   3. Authoritative DNS Server: 실제 개인 도메인과 IP 주소의 관계가 기록/저장/변경되는 서버. 그래서 권한의 의미인 Authoritative가 붙음. 일반적으로 도메인/호스팅 업체의 ‘네임서버’를 말하지만, 개인 DNS 서버 구축을 한 경우에도 여기에 해당함.
   4. Recursive DNS Server: 인터넷 사용자가 가장 먼저 접근하는 DNS 서버임. 위 3개의 DNS 서버를 매번 거친다면 효율이 구데기일 수밖에 없으니, 한 번 거친 후 얻은 데이터를 일정 기간(TTL/Time to Live) 동안 캐시라는 형태로 저장해 두는 서버임. 직접 도메인과 IP 주소의 관계를 기록/저장/변경하지는 않고 캐시만을 보관하기 때문에, Authoritative와 비교되는 의미로 반복의 Recursive가 붙음. 대표적인게 KT/LG/SK와 같은 ISP(통신사) DNS 서버가 있고, 브라우저 우회 용도로 많이 쓰는 구글 DNS, 클라우드플레어와 같은 Public DNS 서버가 있음.
    
```
얄딱구리한 구분으로 혼란스럽게 만드는 웹문서들이 많지만 DNS 서버는 모두 위 4가지 DNS 서버 종류 중 하나에 속함. 
특히, 브라우저는 캐시가 저장된 Recursive 서버를 사용하고, 실제 네임서버를 설정하는 곳은 Authoritative 서버라는 점만 주의해서 이해하면 가장 좋을 듯함. 
나머지 두 서버는 컨트롤할 수 있는 영역도 아니고 언급되는 경우도 적으니 전반적인 이해를 위해서만 요런게 있네~ 정도로 생각하면 좋겠음.
```
### 8-4. 전체적인 DNS 동작 원리

![DNS 동작원리](https://user-images.githubusercontent.com/77487962/128623936-6eb8b256-008d-46bc-a12c-69daa1ceca35.PNG)

1. 브라우저에서 Nesite.com을 검색하고, 사용하고 있는 통신사인 KT DNS 서버에게 도메인 주소에 해당하는 IP 주소를 요청함
(브라우저 기본 DNS 설정이 통신사 DNS 서버이기 때문)

2. ISP 서버에선 캐시 데이터가 없다는 걸 확인하고 루트 DNS 서버에게 어디로 가야 하는지 요청함(캐시가 있다면 8.로 건너 뜀.)

3. 루트 서버는 TLD DNS 서버 주소만 관리하기 때문에, ***.com 도메인을 보고는 COM 최상위 도메인을 관리하는 TLD DNS 서버 주소를 안내함.

4. ISP 서버는 COM 서버에게 어디로 가야 하는지 다시 요청함.

5. COM 서버는 가비아 DNS 서버에서 해당 도메인이 관리되고 있는 걸 확인하고 안내함.

6. ISP 서버는 가비아 서버에게 또 다시 요청함.

7. 가비아 서버는 “Nesite.com = 12.123.123.123”이라는 정보를 확인하고 이 IP를 알려줌. 동시에 ISP 서버는 해당 정보를 캐시로 기록해 둠.

8. ISP 서버는 브라우저에게 힘들게 알아 낸 12.123.123.123 주소를 안내함.

9. 브라우저는 12.123.123.123 IP 주소를 갖고 있는 호스팅 서버에게 웹사이트를 출력하라고 요청함.

10. 드디어 보임.

## 9. 로드밸런서
### 로드밸런서란?

>로드밸런서는 서버에 가해지는 부하(=로드)를 분산(=밸런싱)해주는 장치 또는 기술이다. 클라이언트와 서버풀(Server Pool, 분산 네트워크를 구성하는 서버들의 그룹) 사이에 위치하며, 한 대의 서버로 부하가 집중되지 않도록 트래픽을 관리해 각각의 서버가 최적의 퍼포먼스를 보이도록 함.

### 무조건 필요한가?
* Scale-up : 서버 자체의 성능을 확장하는 것을 의미
* Scale-out : 서버와 동일하거나 낮은 성능의 서버를 두대 이상 증설하여 운영하는 것
> Scale-out의 방식으로 서버를 증설하기로 결정했다면 여러 대의 서버로 트래픽을 균등하게 분산해주는 로드밸런싱이 반드시 필요함

### 로드밸런싱 알고리즘
* 라운드로빈 방식(Round Robin Method)
  * 서버에 들어온 요청을 순서대로 돌아가며 배정하는 방식입니다.
  *  클라이언트의 요청을 순서대로 분배하기 때문에 여러 대의 서버가 동일한 스펙을 갖고 있다.
  *  서버와의 연결(세션)이 오래 지속되지 않는 경우에 활용하기 적합하다.

* 가중 라운드로빈 방식(Weighted Round Robin Method)
  * 각각의 서버마다 가중치를 매기고 가중치가 높은 서버에 클라이언트 요청을 우선적으로 배분
  * 주로 서버의 트래픽 처리 능력이 상이한 경우 사용되는 부하 분산 방식
  * A라는 서버가 5라는 가중치를 갖고 B라는 서버가 2라는 가중치를 갖는다면, 로드밸런서는 라운드로빈 방식으로 A 서버에 5개 B 서버에 2개의 요청을 전달

* IP 해시 방식(IP Hash Method)
  * IP 주소를 특정 서버로 매핑하여 요청을 처리하는 방식
  * 사용자의 IP를 해싱해(Hashing, 임의의 길이를 지닌 데이터를 고정된 길이의 데이터로 매핑하는 것, 또는 그러한 함수) 로드를 분배
  * 사용자가 항상 동일한 서버로 연결되는 것을 보장

* 최소 연결 방식(Least Connection Method)
  * 요청이 들어온 시점에 가장 적은 연결상태를 보이는 서버에 우선적으로 트래픽을 배분
  * 세션이 길어지거나, 서버에 분배된 트래픽들이 일정하지 않은 경우에 적합한 방식

* 최소 리스폰타임(Least Response Time Method)
  * 서버의 현재 연결 상태와 응답시간(Response Time, 서버에 요청을 보내고 최초 응답을 받을 때까지 소요되는 시간)을 모두 고려하여 트래픽을 배분
  * 적은 연결 상태와 가장 짧은 응답시간을 보이는 서버에 우선적으로 로드를 배분하는 방식

### L4 로드밸런서와 L7 로드밸런서
![image](https://user-images.githubusercontent.com/58085920/130321914-93c2cf2d-d2b5-403e-b0dc-7e00f312b387.png)
![image](https://user-images.githubusercontent.com/58085920/130321918-b265a817-98cc-4187-afa2-2f1fb8b391e7.png)

>부하 분산에는 L4 로드밸런서와 L7 로드밸런서가 가장 많이 활용된다. 그 이유는 L4 로드밸런서부터 포트(Port)정보를 바탕으로 로드를 분산하는 것이 가능하기 때문이다. 한 대의 서버에 각기 다른 포트 번호를 부여하여 다수의 서버 프로그램을 운영하는 경우라면 최소 L4 로드밸런서 이상을 사용해야만 한다.

* L4 로드밸런서는 네트워크 계층(IP, IPX)이나 트랜스포트 계층(TCP, UDP)의 정보를 바탕으로 로드를 분산
* IP주소나 포트번호, MAC주소, 전송 프로토콜에 따라 트래픽을 나누는 것이 가능

* L7 로드밸런서는 애플리케이션 계층(HTTP, FTP, SMTP)에서 로드를 분산
* HTTP 헤더, 쿠키 등과 같은 사용자의 요청을 기준으로 특정 서버에 트래픽을 분산하는 것이 가능
* 패킷의 내용을 확인하고 그 내용에 따라 로드를 특정 서버에 분배하는 것이 가능
* L7 로드밸런서의 경우 특정한 패턴을 지닌 바이러스를 감지해 네트워크를 보호할 수 있으며, DoS/DDoS와 같은 비정상적인 트래픽을 필터링할 수 있어 네트워크 보안 분야에서도 활용됨

![image](https://user-images.githubusercontent.com/58085920/130321737-3371e9c6-3071-492e-9f05-d5ddc8d37b5b.png)



#  NetWork
**:book: Contents**
+ [1. OSI 7계층]
+ [2. TCP/IP]
+ [3. TCP vs UDP]
  + [3-1. TCP]
  + [3-2. TCP의 3-way handshake 와 4-way handshake]
  + [3-3. UDP]
+ [4. HTTP vs HTTPS]
  + [4-1. HTTP]
  + [4-2. HTTPS]
+ [5. GET vs POST]
  + [5-1. GET]
  + [5-2. POST]
+ [6. Cookie(쿠키) vs Session(세션)]
  + [6-1. Cookie(쿠키)]
  + [6-2. Session(세션)]
+ [7. Rest 와 Restful]
  + [7-1. Rest]
  + [7-2. Rest API]
  + [7-3. Restful]

## 1. OSI 7계층
  + OSI (Open Systems Interconnection Reference Model)
    + 국제표준화기구(ISO)에서 개발한 모델, 컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명한 것
    + 프로토콜을 기능별로 나눈 것이다.
    + 각 계층은 하위 계층의 기능만을 이요하고, 상위 계층에게 기능을 제공
  + [1. 물리계층 (Physical layer)]
    + 네트워크의 기본 네트워크 하드웨어 전송 기술을 이룬다.
    + 네트워크의 높은 수준의 기능의 논리 데이터 구조를 기초로 하는 필수 계층
    + 전송 단위는 Bit
  + [2. 데이터 링크 계층 (Data link layer)]
    + 장치 간 신호를 전달하는 물리 계층을 이용하여 네트워크 상의 주변 장치들 간 데이터 전송
    + 주소 할당 : 물리 계층으로부터 받은 신호들이 네트워크 상의 장치에 올바르게 안착할 수 있게 함
    + CRC 기반 오류 감지 : 신호가 전달되는 동안 오류가 포함되는지를 감지한다.
      ```
      CRC (Cyclic Redundancy Check)
        * 네트워크 등을 통하여 데이터를 전송할 때 전송된 데이터에 오류가 있는지를 확인하기 위한 체크값 결정 방식
        * 전송 전 데이터의 값에 따른 CRC 값을 붙여 전송, 전송 후 받은 데이터의 값으로 CRC 값 계산 후 비교( 다르면 오류)
      ```
    + 전송 단위는 프레임(Frame)
  + [3. 네트워크 계층 (Network layer)]
    + 라우팅(Routing)을 포함한 패킷 포워딩을 담당하는 계층
    + 라우팅(Routing) : 네트워크 안에서 데이터를 전송할 때 경로를 선택하는 과정
    + 패킷 포워딩(Forwarding) : 라우팅으로 저장된 경로에 패킷을 보내는 작업
    + 전송 단위는 패킷(Packet)
  + [4. 전송 계층 (Transport layer)]
    + 실사용자(end-to-end)가 신뢰성 있는 데이터를 주고 받을 수 있도록 해주는 계층
    + 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해줌
    + 시퀀스 넘버 기반의 오류 제어 방식을 사용
      ```
      시퀀스 넘버
        * 통신과 제어에서 데이터를 관리하기 위해 번호를 부여
        * 해당 번호는 순서 역전 방지, 중복 패킷 방지 등으로 사용
      ```
    + 특정 연결의 유효성을 제어, 일부 프로토콜은 상태 개념이 있고(stateful), 연결 기반(connection oriented)
      <br> -> 패킷들의 전송이 유효한지 확인 후 전송 실패한 패킷들은 다시 전송
    + 전송 단위는 세그먼트(Segment)
  + [5. 세션 계층 (Session layer)]
    + 데이터 통신(송수신)을 관리하기 위한 방법을 제공하는 계층
    + 통신 방법 제공 : 동시 송수신 방식(duplex), 반이중 방식(half-duplex), 전이중 방식(Full duplex)의 통신 제공
    + 체크 포인팅과 종료, 다시 시작 과정 등을 수행
    + TCP/IP 세션을 만들고 없애는 책임을 진다.
  + [6. 표현 계층 (Presentation layer)]
    + 네트워크의 데이터 번역자의 역할(응용 형식 -> 네트워크 형식, 네트워크 형식 -> 응용 형식)
    + MIME 인코딩이나 암호화 등의 동작이 이루어진다.
  + [7. 응용 계층 (Application layer)]
    + 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.

## 2. TCP/IP
  > https://brunch.co.kr/@wangho/6
  + TCP/IP
    + 패킷 통신 방식의 인터넷 프로토콜인 IP (인터넷 프로토콜)와 전송 조절 프로토콜인 TCP (전송 제어 프로토콜)로 이루어짐
    + IP는 복잡한 네트워크 망을 통하여 가장 효율적인 방법으로 데이터의 작은 조각들을 되도록 빨리 보내는 일
    + TCP는 데이터를 잘게 잘라 보내면서 순서가 맞지 않거나 중간에 빠진 부분을 점검하여 다시 요청
  + [1. 네트워크 연결 계층 (Network Access Layer)]
    + 데이터 단위 : 프레임(Frame), 전송 주소 : MAC 주소
    + 물리적으로 데이터가 네트워크를 통해 어떻게 전송되는지를 정의
      + 논리 주소(IP주소 등)이 아닌 물리주소(MAC주소)을 참조해 전송
      <br> MAC 주소(Media Access Control Address) : 컴퓨터의 하드웨어 주소
    + 기본적으로 에러검출 / 패킷의 프레임화 담당
  + [2. 인터넷 계층 (Internet Layer)]
    + 데이터 단위 : 패킷(Packet), 전송 주소 : IP 주소
    + 네트워크상 최종 목적지까지 정확하게 연결되로고 연결성 제공
    + 단말을 구분하기 위해 논리적인 주소(Logical Address) IP를 할당
    + 라우팅(Routing) 기능을 처리
    + 패킷 단위의 데이터 
  + [3. 전송 계층 (Transport Layer)]
    + 데이터 단위 : 세그먼트(Segment), 전송 주소 : 포트(Port)
    + 통신 노드 간의 연결 제어 및 자료 송수신을 담당
  + [4. 응용 계층 (Application Layer)]
    + 데이터 단위 : Data / Message
    + 응용 프로그램(Application)들이 데이터를 교환하기 위해 사용되는 프로토콜
    + 사용자 응용 프로그램 인터페이스를 담당
 
## 3. TCP vs UDP
#### 3-1. TCP
  + TCP (Transmission Control Protocol)
    + 인터넷 상에서 데이터를 메세지의 형태(세그먼트 라는 블록 단위)로 보내기 위해 IP와 함게 사용하는 프로토콜
    + TCP와 IP를 함께 사용하는데, IP는 데이터의 배달을 처리, TCP는 패킷을 추적
    + 연결형 서비스로 가상 회선 방식을 제공
      + 3-way handshaking 과정을 통해 연결을 설정, 4-way handshaking을 통해 연결을 해제
    + 흐름 제어 (Flow Control)
      + 수신측이 송신측보다 데이터 처리 속도가 빠르면 문제없지만, 송신측의 속도가 빠를 경우 문제 발생
      + 수신측에서 제한된 저장 용량 초과한 후 도착하는 데이터는 손실 될 수 있으며, 만약 손실시 불필요한 응답, 데이터 전송이 송수신 측간에 빈번이 발생
      + 데이터를 송신하는 곳과 수신하는 곳의 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우 방지
      + 해결 방법
        + Stop and Wait : 매번 전송한 패킷에 대해 확인 응답을 받아야만 다음 패킷을 전송하는 방법
        + Sliding Window (Go Back N ARQ) : 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인 응답없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어기법
        ```
        * 목적 : 전송은 되었지만, ACK를 받지 못한 byte의 숫자를 파악하기 위해 사용하는 protocol
        (LastByteSent - LastByteAcked <= ReceiveWindowAdvertised)
        마지막에 보내진 바이트 - 마지막에 확인된 바이트 <= 남아있는 공간
        * 동작 방식
          1. 윈도우에 포함되는 모든 패킷을 전송
          2. 그 패킷들의 전달이 확인되는 대로 윈도우를 옆으로 옮김으로써 다음 패킷들을 전송
        ```
    + 혼잡 제어 (Congestion Control)
      + 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지
      + 정보의 소통량이 과다하면 패킷을 조금만 전송하여 혼잡 붕괴 현상이 일어나는 것을 방지
      + 해결 방법
        + AIMD (Additive Increase / Multiplicative Decrease)
        + Slow Start (느린 시작)
        + Fast Retransmit (빠른 재전송)
        + Fast Recovery (빠른 회복)
    + 높은 신뢰성을 보장
    + UDP보다 속도가 느림
    + 전이중(Full-Duplex), 점대점(Point to Point) 방식
      + 전이중
        + 전송이 양방향으로 동시에 일어날 수 있다.
      + 점대점
        + 각 연결이 정확히 2개의 종단점을 가지고 있다.
      + 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다.
      ```
      * 유니캐스팅
        - MAC 주소를 기반으로 상대측 IP주소를 목적지로 하는 일대일 통신 방식
      * 멀티캐스팅
        - UDP 기반
        - 하나 이상의 송신자들이 특정한 하나 이상의 수신자들에게 데이터를 전송하는 방식
      * 브로드캐스팅
        - UDP 기반
        - 로컬 랜상에 붙어있는 모든 네트워크 장비들에게 그들의 의사와 상관없이 모두 보내는 방식
      ```
    + 연속성보다 신뢰성있는 전송이 주요할 때에 사용
### 3-2. TCP의 3-way handshake 와 4-way handshake
  + TCP는 장치들 사이에 논리적인 접속을 성립하기 위하여 연결을 설정하여 신뢰성을 보장하는 연결형 서비스
  + 3-way handshake
    + TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정하는 과정
    + 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장, 실제로 데이터 전달이 시작하기 전에 한 쪽이 다른 쪽이 준비되었음을 알 수 있음
    + 즉, TCP/IP 프로토콜을 이용해서 통신을 하는 응용 프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미
    + 동작 과정
      + A 프로세트(Client)가 B 프로세스(Server)에 연결을 요청
        + 1. A -> B : SYN
          + 접속 요청 프로세스 A가 연결 요청 메시지 전송(SYN)
          + 송신자가 최초로 데이터를 전송할 때 시퀀스 넘버(Sequence Number)를 임의의 랜덤 숫자로 지정, SYN 플래그 비트를 1로 설정한 세그먼트 전송
          + PORT 상태 : A - CLOSED, B : LISTEN
        + 2. B -> A : SYN + ACK
          + 접속 요청을 받은 프로세스 B가 요청을 수락했으며, 접속 요청 프로세스인 A도 포트를 열어 달라는 메시지 전송 (SYN + ACK)
          + 수신자는 Acknowledgement Number 필드를 (Sequence Number + 1)로 지정, SYN과 ACK 플래그 비트를 1로 설정한 세그먼트를 전송
          + PORT 상태 : A : CLOSED, B : SYN_RCV
        + 3. A -> B : ACK
          + 마지막으로 접속 요청 프로세스 A가 수락 확인을 보내 연결을 맺음 (ACK)
          + 데이터 전송이 가능
          + PORT 상태 : A : ESTABLISHED, B : ESTABLISHED
  + 4-way handshake
    + TCP의 연결을 해제하는 과정
      + A 프로세스(Client)가 B 프로세스(Server)에 연결 해제를 요청
        + 1. A -> B : FIN
          + 프로세스 A가 연결을 종료하겠다는 FIN 플래그 전송
          + 프로세스 B가 FIN 플래그로 응답하기 전까지 연결 유지
        + 2. B -> A : ACK
          + 프로세스 B는 일단 확인 메시지 전송 자신의 통신이 끝날 때까지 기다림(이 상태가 TIME_WAIT 상태)
          + 수신자는 Acknowledgement Number 필드를 (Sequence Number + 1)로 지정하고, ACK 플래그 비트를 1로 설정한 세그먼트 전송
          + 자신이 전송할 데이터가 남아있다면 이어서 전송
        + 3. B -> A : FIN
          + 프로세스 B가 통신이 끝나면 연결 종료 요청에 합의한다는 의미로 프로세스 A에게 FIN 플래그 전송
        + 4. A -> B : ACK
          + 프로세스 A는 확인했다는 메시지 전송
  ```
  포트(Port) 상태 정보
    - CLOSED : 포트가 닫힌 상태
    - LISTEN : 포트가 열린 상태로 연결 요청 대기
    - SYN_RCV : SYNC 요청을 받고 상대방의 응답을 기다리는 중
    - ESTABLISHED : 포트 연결 상태
  ```
### 3-3. UDP
  + UDP (User DAtagram Protocol)
    + 데이터를 데이터그램 단위로 처리하는 프로토콜
    + 비연결형 서비스로 데이터그램 방식을 제공
      + 연결을 위해 할당되는 논리적인 경로가 없다.
      <br> -> 각각의 패킷은 다른 경로로 전송되고, 각각의 패킷은 독립적인 관계를 지니게 된다.
      <br> -> 데이터를 서로 다른 경로로 독립적으로 처리한다.
    + 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않음
    + UDP 헤더의 CheckSum 필드를 통해 최소한의 오류만 검출
    <br> `CheckSum : 중복 검사의 한 형태, 송신된 자료의 무결성을 보호하는 단순한 방법`
    + 신뢰성이 낮다.
    + TCP보다 속도가 빠르다.
    + 신뢰성보다는 연속성이 중요한 서비스, 예를 들면 실시간 서비스(Streaming)에 사용
   ```
    참고
      - UDP와 TCP는 각각 별도의 포트 주소 공간을 고나리하므로 같은 포트 번호 사용해도 무방
      - 같은 모듈(TCP or UDP) 내에서도 클라이언트 프로그램에서 동시에 여러 커넥션을 확립한 경우 서로 다른 포트 번호 동적 할당
   ```
## 4. HTTP vs HTTPS
### 4-1. HTTP (HyperText Transfer Protocol)
  + HTTP 프로토콜
    + 개념
      + 웹 상에서 클라이언트와 서버 간에 요청/응답(Request/Response)으로 정보를 주고 받을 수 있는 프로토콜
    + 특징
      + 주로 HTML 문서를 주고 받는데 사용
      + TCP와 UDP를 사용, 80번 포트 사용
      + 비연결(Connectionless)
        + 클라이언트가 요청을 서버에 보내고 서버가 적절한 응답을 클라이언트에 보내면 바로 연결이 끊긴다.
      + 무상태(Stateless)
        + 연결을 끊는 순간 클라이언트와 서버의 통신은 끝나며 상태 정보를 유지하지 않는다. ex) 화면 이동 시 다시 로그인을 하여야 됨(쿠키에 저장하기 전)
    ```
      동작 과정 ex)웹브라우저에 google.com 치면 일어나는 과정
        1. 사용자가 웹 브라우저에 URL 주소 입력
        2. DNS 서버에 웹 서버의 호스트 이름을 IP 주소로 변경 요청
        3. 웹 서버와 TCP 연결 시도(3-way handshake)
        4. 클라이언트가 서버에 요청(Request)
        5. 서버가 클라이언트에게 응답(Response)
        6. 서버 클라이언트간 연결 종료(4-way handshake)
        7. 웹 브라우저가 웹 문서 출력
    ```
### 4-2. HTTPS (HyperText TRansfer Protocol Secure)
  + HTTPS 프로토콜
    + 개념
      + 웹 통신 프로토콜 HTTP의 보안이 강화된 버전의 프로토콜
    + 특징
      + HTTPS의 기본 TCP/IP 포트 443번 포트 사용
      + 소켓 통신에서 일반 텍스트를 이용하는 대신, 웹 상에서 정보를 암호화하는 SSL이나 TLS 프로토콜을 통해 세션 데이터 암호화
      ```
      TLS(Transport Layer Security), SSL(Secure Socket Layer)
        - TLS 프로토콜은 SSL 프로토콜에서 발전한 것이다.
        - 개인 정보 및 금융 정보를 포함한 전송되는 모든 정보를 열람하거나 훔치는 것을 방지
      ```
      + 데이터의 적절한 보호를 보장한다.
        + 보호 수준은 웹 브라우저에서의 구현 정확도와 서버 소프트웨어, 지원하는 암호화 알고리즘에 따라 다름
      + 금융 정보, 메일 등 중요한 저옵를 주고받는 것은 HTTPS, 아무나 봐도 되는 내용은 HTTP를 사용
    ```
    HTTPS가 필요한 이유?
      - 클라이언트인 웹 브라우저가 서버에 웹 페이지나 이미지 정보 요청하면 서버가 응답하여 요구에 따른 정보 제공
      - 웹 페이지(HTML)은 텍스트이고, HTTP를 통해 정보 교환
      - 정보에 주민등록번호나 비밀번호와 같은 정보가 포함된 상태로 중간에 제3자가 정보를 가로채면 보안 문제 발생
      - 중간에 볼 수 없도록 정보를 암호화하는 방법인 HTTPS를 사용
    ```
    - HTTPS의 장단점
      - 장점
        - 네트워크 상에서 열람, 수정이 불가능하므로 안전
      - 단점
        - 암호화를 하는 과정에 웹 서버에 부하를 준다.
        - 설치 및 인증서를 유지하는데 추가 비용 발생
        - HTTP에 비해 느리다.
        - 인터넷 연결이 끊긴 경우 재인증 시간이 소요
          - HTTP는 비연결형으로 웹 페이지를 보는 도중 인터넷 연결이 끊겻다가 다시 연결되어도 페이지를 계속 볼 수 있다.
          - HTTPS는 소켓(데이터를 주고 받는 경로) 자체에서 인증하기 때문에 끊기면 소켓도 끊어져서 다시 인증이 필요
    ```
    동작 과정
      1. 클라이언트가 생성한 랜덤 데이터 서버에 전송
      2. 서버가 생성한 랜덤 데이터 클라이언트에 전송
      3. 클라이언트 인증 확인
        3-1. 서버로 부터 받은 인증서가 CA에 의해 발급되었는지 본인이 가지고 있는 목록에서 확인
        3-2. 있다면 CA 공개키로 인증서 복호화
        3-3. 클라이언트, 서버 각각의 랜덤 데이터를 조합하여 pre master secret 값 생성(데이터 송수신 시 대칭키 암호화에 사용할 키)
        3-4. pre master secret 값을 공개키 방식으로 서버 전달(공개키는 서버로부터 받은 인증서에 포함)
        3-5. session key 생성
      4. 서버 인증 확인
        4-1. 서버는 비공개키로 복호화하여 pre master secret 값 취득(대칭키 공유 완료)
        
      ```
## GET 메서드와 POST 메서드
### HTTP 프로토콜을 이용해서 서버에 데이터(요청 정보)를 전달할 때 사용하는 방식
#### GET 메서드 방식
+ 개념
  + 정보를 조회하기 위한 메서드
  + 서버에서 어떤 데이터를 가져와서 보여주기 위한 용도의 메서드
  + 가져오는 것(Select)
+ 사용 방법
  + URL의 끝에 '?'가 붙고, 요청 정보가 (key=value)형태의 쌍을 이루어 ?뒤에 이어서 붙어 서버로 전송한다.
  + 요청 정보가 여러 개일 경우에는 '&'로 구분한다.
  + Ex) www.urladdress.xyz?name1=value1&name2=value2
+ 특징
  +  URL에 요청 정보를 붙여서 전송한다.
  +  URL에 요청 정보가 이어붙기 때문에 길이 제한이 있어서 대용량의 데이터를 전송하기 어렵다.
      +  한 번 요청 시 전송 데이터(주솟값 + 파라미터)의 양은 255자로 제한된다.(HTTP/1.1은 2048자)
  +  요청 정보를 사용자가 쉽게 눈으로 확인할 수 있다.
      +  POST 방식보다 보안상 취약하다.
  +  HTTP 패킷의 Body는 비어 있는 상태로 전송한다.
      +  즉, Body의 데이터 타입을 표현하는 'Content-Type' 필드도 HTTP Request Header에 들어가지 않는다.
  +  POST 방식보다 빠르다.
      +  GET 방식은 캐싱을 사용할 수 있어, GET 요청과 그에 대한 응답이 브라우저에 의해 캐쉬된다.
#### POST 메서드 방식
+ 개념
  + 서버의 값이나 상태를 바꾸기 위한 용도의 메서드
    + 수행하는 것(Insert, Update, Delete)
+ 사용 방법
  + 요청 정보를 HTTP 패킷의 Body 안에 숨겨서 서버로 전송한다.
  + Request Header의 Content-Type에 해당 데이터 타입이 표현되며, 전송하고자 하는 데이터 타입을 적어주어야 한다.
  + Default: application/octet-stream
  + 단순 txt의 경우: text/plain
  + 파일의 경우: multipart/form-date
+ 특징
  + Body 안에 숨겨서 요청 정보를 전송하기 때문에 대용량의 데이터를 전송하기에 적합하다.
  + 클라이언트 쪽에서 데이터를 인코딩하여 서버로 전송하고, 이를 받은 서버 쪽이 해당 데이터를 디코딩한다.
  + GET 방식보다 보안상 안전하다.
```
Q. 조회하기 위한 용도 POST가 아닌 GET 방식을 사용하는 이유?
  1. 설계 원칙에 따라 GET 방식은 서버에게 여러 번 요청을 하더라도 동일한 응답이 돌아와야 한다. (Idempotent, 멱등)
    GET 방식은 가져오는 것(Select) 으로, 서버의 데이터나 상태를 변경시키지 않아야 한다.
    Ex) 게시판의 리스트, 게시글 보기 기능
    예외) 방문자의 로그 남기기, 글을 읽은 횟수 증가 기능
    POST 방식은 수행하는 것 으로, 서버의 값이나 상태를 바꾸기 위한 용도이다.
    Ex) 게시판에 글쓰기 기능
  2. 웹에서 모든 리소스는 Link할 수 있는 URL을 가지고 있어야 한다.
    어떤 웹페이지를 보고 있을 때 다른 사람한테 그 주소를 주기 위해서 주소창의 URL을 복사해서 줄 수 있어야 한다.
    즉, 어떤 웹페이지를 조회할 때 원하는 페이지로 바로 이동하거나 이동시키기 위해서는 해당 링크의 정보가 필요하다.
    이때 POST 방식을 사용할 경우에 값(링크의 정보)이 Body에 있기 때문에 URL만 전달할 수 없으므로 GET 방식을 사용해야한다. 
    그러나 글을 저장하는 경우에는 URL을 제공할 필요가 없기 때문에 POST 방식을 사용한다.
```      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
